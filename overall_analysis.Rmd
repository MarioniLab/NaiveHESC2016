---
title: "Single-cell RNA-seq of naive/primed embryonic stem cells: overall analysis"
author: Tobias Messmer and Aaron Lun
date: 17 December 2016
output: 
  html_document:
    toc: true
    toc_float: true
    depth: 3
    number_sections: true
    theme: united 
    highlight: tango
    fig_caption: false
---

```{r, echo=FALSE, results="hide"}
dir.create("figure-overall/", showWarning=FALSE)
knitr::opts_chunk$set(error=FALSE, warning=FALSE, message=FALSE, fig.path="figure-overall/")
options(bitmapType="cairo", width=100)
library(BiocParallel)
register(SerialParam())
```

# Reading in the data 

First, we read in the processed data set.

```{r readin}
library(scran)
sce <- readRDS("sce_all.rds")
sce
```

To get a first impression of the data, expression profiles of typical ESC markers are plotted. 
This is done after shuffling the cell order to avoid all naive cells being plotted after primed cells.

```{r explot}
set.seed(100)
sce <- sce[, sample(ncol(sce))]
fontsize <- theme(axis.text=element_text(size=12), axis.title=element_text(size=16))
plotExpression(sce, c("KLF4", "KLF17", "DPPA3", "TFCP2L1", "NANOG", "ZFP42", "POU5F1"), 
    colour_by="phenotype", shape_by = "batch", show_violin = FALSE) + fontsize
```

There is a strong batch effect in this data, so we construct a design matrix containing batch blocking factors.
This ensures that downstream results will not be driven by differences between batches.

```{r makedesign}
design <- model.matrix(~0 + sce$batch)
```

Based on the variabilty of gene expression over the whole population, we can identify subpopulations within the data set. 
As we already know that the cells are either in a naive or primed state, this clustering serves mainly as confirmation. 

Finally, we set up a directory to save various results into.

```{r}
resdir <- "results-overall"
dir.create(resdir, showWarning=FALSE)
```

# Detecting highly variable genes across all cells

We fit a trend to the variances of the spike-ins.
This represents the technical variance at any given mean count.
For each endogenous gene, the difference between the technical and total variance is the biological component of variability.
We do this separately for each batch, as there is at least an order of magnitude difference in the amount of spike-in added to each batch.

```{r trendvarfit, fig.height=6, fig.width=10}
par(mfrow=c(1,2))
collected.var <- list()
for (b in levels(sce$batch)) {
    cur.sce <- sce[,sce$batch==b]
    cur.sce <- normalize(cur.sce)
    var.fit <- trendVar(cur.sce, method="loess", span=0.4)
    collected.var[[b]] <- decomposeVar(cur.sce, var.fit)
    plot(var.fit$mean, var.fit$var, pch=16, col="grey", xlab="Mean log-expression",
         ylab="Variance of log-expression", ylim=c(0, 10), xlim=c(0, 15), main=paste("Batch", b))
    curve(var.fit$trend(x), col="red", add=TRUE, lwd=2)
    }
```

The trend passes through the bulk of the spike-ins, which is reassuring.
We combine the statistics across batches (using Berger's IUT to select genes that are HVG in all batches) and save them to file.

```{r combinevar}
var.out <- do.call(combineVar, c(collected.var, method="berger"))
write.table(file=file.path(resdir, "var.tsv"), var.out, sep="\t", quote=FALSE, col.names = NA) 
```

We examine the distribution of variances for the endogenous genes.
Many genes have variances above this trend, corresponding to strong heterogeneity across the population.

```{r plotvar}
par(mfrow=c(1,1))
plot(var.out$mean, var.out$total, pch=16, cex=0.6, xlab="Mean log-expression",
     ylab="Variance of log-expression")
is <- which(isSpike(sce))
points(var.out$mean[is], var.out$total[is], col="red", pch=16)
o <- is[order(var.out$mean[is])]
curve(var.fit$trend(x), col='dodgerblue', lwd=2, add=TRUE)
```

The computed variance can be used to identify highly variable genes, which are subsequently saved to file. 

```{r highvar}
hvg.out <- var.out[which(var.out$FDR <= 0.05 & var.out$bio >= 0.5),]
nrow(hvg.out)
hvg.out <- hvg.out[order(hvg.out$bio, decreasing=TRUE),]
write.table(file = file.path(resdir, "hvg.tsv"), hvg.out, sep="\t", quote=FALSE, col.names = NA) 
head(hvg.out)
```

The most highly variable genes across the whole population are shown to ensure that they are not driven by one or two outliers.

```{r vioplot}
plotExpression(sce, rownames(hvg.out)[1:10], alpha=0.5, 
    colour_by="phenotype", jitter="jitter") + fontsize 
```

# Detecting highly correlated genes.

We identify HVGs with strong correlations to at least one other HVG.
These genes are most likely to be driving substructure in the data, though there are also correlations due to tightly coordinated pathways (ribosomal) and mapping spillover.
For convenience, we only take the top 1000 genes with the largest biological components.

```{r correlation}
set.seed(100) 
var.cor <- correlatePairs(sce, design = design, subset.row=rownames(hvg.out)[1:1000], per.gene=TRUE) 
head(var.cor)
sig.cor <- var.cor$FDR <= 0.05
summary(sig.cor)
```

We save these correlated HVGs for later use. 
As it happens, all (or almost all) of the top HVGs were detected as being correlated with at least one other HVG, so it ends up that we use all of them.

```{r chosencor}
chosen <- var.cor$gene[sig.cor]
length(chosen)
saveRDS(chosen, file = file.path(resdir, "cor_hvg.rds"))
```

```{r, echo=FALSE, results='hide'}
rm(var.cor, sig.cor)
gc()
```

# Dimensionality reduction using correlated HVGs

We perform dimensionality reduction using _t_-SNE, colouring by various attributes.
We use `norm_exprs` in which the batch effect has already been removed.

```{r tsne, fig.height=10, fig.width=10}
tsne1 <- plotTSNE(sce, exprs_values="norm_exprs", colour_by=rownames(hvg.out)[1],
    perplexity=30, rand_seed=100, feature_set=chosen) + fontsize
tsne2 <- plotTSNE(sce, exprs_values="norm_exprs", colour_by="KLF4",
    perplexity=30, rand_seed=100, feature_set=chosen) + fontsize
tsne3 <- plotTSNE(sce, exprs_values="norm_exprs", colour_by="batch",
    perplexity=30, rand_seed=100, feature_set=chosen) + fontsize
tsne4 <- plotTSNE(sce, exprs_values="norm_exprs", colour_by="phenotype",
    perplexity=30, rand_seed=100, feature_set=chosen) + fontsize
multiplot(tsne1, tsne3, tsne2, tsne4, cols=2)
```

We repeat this with PCA, which is simpler but provides more stable results.

```{r pca, fig.height=10, fig.width=10}
pca1 <- plotPCA(sce, exprs_values="norm_exprs", colour_by=rownames(hvg.out)[1], 
    feature_set = chosen) + fontsize
pca2 <- plotPCA(sce, exprs_values="norm_exprs", colour_by="KLF4", 
    feature_set = chosen) + fontsize
pca3 <- plotPCA(sce, exprs_values="norm_exprs", colour_by="batch", 
    feature_set = chosen) + fontsize
pca4 <- plotPCA(sce, exprs_values="norm_exprs", colour_by="phenotype", 
    feature_set = chosen) + fontsize
multiplot(pca1, pca3, pca2, pca4, cols=2)
```

# Differential expression analysis

## Testing for differences between naive and primed

Finally, we test for differences in expression between the naive and primed conditions.
This is done using _edgeR_, after summing all cells within each batch to create a pseudo-bulk sample.

```{r desetup}
library(edgeR)
de.counts <- sumTechReps(counts(sce), paste(sce$phenotype, sce$batch, sep="."))
de.counts <- de.counts[!isSpike(sce),] # removing spikes
y <- DGEList(de.counts)
```

We construct a new design matrix for the summed samples.

```{r}
ptype <- factor(sub("\\..", "\\1", colnames(de.counts)))
batch <- factor(sub("^.*\\.", "\\1", colnames(de.counts)))
design_pheno <- model.matrix(~0 + ptype + batch) 
```

We run through _edgeR_'s analysis pipeline. 
First, we normalize the samples using the TMM method.

```{r}
y <- calcNormFactors(y)
y$samples
```

We estimate the negative binomial dispersion, which represents the variability between replicates.
For true bulk RNA-seq experiments, we'd expect BCV values around 0.1 or lower, though the values here will be higher as they are derived from noisier single-cell values.

```{r nbdisp}
y <- estimateDisp(y, design_pheno)  
plotBCV(y)
```

We fit a generalized linear model, with estimates of the quasi-likelihood dispersion to account for gene-specific variability.

```{r qldisp}
fit <- glmQLFit(y, design_pheno, robust=TRUE) 
plotQLDisp(fit)
```

Finally, we set up contrasts between the primed and naive population.
We use the QL F-test to test for significant differences in expression.

```{r ftrest}
con <- makeContrasts(ptypenaive - ptypeprimed, levels = design_pheno)
res <- glmQLFTest(fit, contrast=con)
summary(decideTestsDGE(res))
DEmarkers <- topTags(res, n=Inf)$table
write.table(DEmarkers, file=file.path(resdir, "de.tsv"), sep="\t", quote=FALSE, col.names=NA) 
head(DEmarkers)
```

This is shown in more detail using the smear plot below.

```{r smearplot}
is.sig <- DEmarkers$FDR <= 0.05
plotSmear(res, de.tags=rownames(DEmarkers)[is.sig], cex=0.1)
```

To ensure that the top DE genes are not driven by outliers, we can examine them explicitly.

```{r viode}
plotExpression(sce, features = rownames(DEmarkers)[1:10], col = "phenotype")
```

## Interpreting the set of DE genes

We use the DE genes for gene set analyses.
First, we take the set of genes that were upregulated in naive over primed.

```{r upgo}
library(GO.db)
library(org.Hs.eg.db)
up.genes <- rownames(DEmarkers)[is.sig & DEmarkers$logFC > 0]
is.up <- rownames(sce) %in% up.genes
entreznames <- data.frame(rowData(sce)$entrezgene)
has.entrez <- !is.na(entreznames)
go <- goana(entreznames[has.entrez & is.up], universe=entreznames[has.entrez], species = "Hs")
topgo <- topGO(go, n=Inf, ontology = "BP") 
write.table(file=file.path(resdir, "go_up.tsv"), topgo, sep="\t", quote=FALSE, col.names = NA) 
head(topgo)
```

We repeat the dose for KEGG analyses.

```{r upkegg}
kegg <- kegga(entreznames[has.entrez & is.up], universe=entreznames[has.entrez], species = "Hs")
topkegg <- topKEGG(kegg, n=Inf)
write.table(file=file.path(resdir, "kegg_up.tsv"), topkegg, sep="\t", quote=FALSE, col.names = NA) 
head(topkegg)
```

We now turn our attention to the downregulated genes, i.e., those expressed in primed and not naive.

```{r downgo}
down.genes <- rownames(DEmarkers)[is.sig & DEmarkers$logFC < 0]
is.down <- rownames(sce) %in% down.genes
go <- goana(entreznames[has.entrez & is.down], universe=entreznames[has.entrez], species = "Hs")
topgo <- topGO(go, n=Inf, ontology = "BP") 
write.table(file=file.path(resdir, "go_down.tsv"), topgo, sep="\t", quote=FALSE, col.names = NA) 
head(topgo)
```

We repeat for KEGG analyses.

```{r downkegg}
kegg <- kegga(entreznames[has.entrez & is.down], universe=entreznames[has.entrez], species = "Hs")
topkegg <- topKEGG(kegg, n=Inf)
write.table(file=file.path(resdir, "kegg_down.tsv"), topkegg, sep="\t", quote=FALSE, col.names = NA) 
head(topkegg)
```

# Wrapping up

There's nothing else to save, so we just report the session information here.

```{r}
sessionInfo()
```
