---
title: "Single-cell RNA-seq of naive/primed embryonic stem cells: overall analysis"
author: Tobias Messmer and Aaron Lun
date: 13 November 2017
output: 
  html_document:
    toc: true
    toc_float: true
    depth: 3
    number_sections: true
    theme: united 
    highlight: tango
    fig_caption: false
---

```{r, echo=FALSE, results="hide"}
dir.create("figure-overall/", showWarning=FALSE)
knitr::opts_chunk$set(error=FALSE, warning=FALSE, message=FALSE, fig.path="figure-overall/")
options(bitmapType="cairo", width=100)
library(BiocParallel)
register(SerialParam())
```

# Reading in the data 

First, we read in the processed data set.

```{r readin}
library(scran)
sce <- readRDS("sce_all.rds")
sce
```

To get a first impression of the data, expression profiles of typical ESC markers are plotted. 
This is done after shuffling the cell order to avoid all naive cells being plotted after primed cells.

```{r explot}
library(scater)
set.seed(100)
shuffled.sce <- sce[, sample(ncol(sce))]
fontsize <- theme(axis.text=element_text(size=12), axis.title=element_text(size=16))
plotExpression(shuffled.sce, c("KLF4", "KLF17", "DPPA3", "TFCP2L1", "NANOG", "ZFP42", "POU5F1"), 
    colour_by="phenotype", shape_by = "batch", show_violin = FALSE) + fontsize
```

There is a strong batch effect in this data, so we construct a design matrix containing batch blocking factors.
This ensures that downstream results will not be driven by differences between batches.

```{r makedesign}
design <- model.matrix(~0 + sce$batch)
```

Based on the variabilty of gene expression over the whole population, we can identify subpopulations within the data set. 
As we already know that the cells are either in a naive or primed state, this clustering serves mainly as confirmation. 

Finally, we set up a directory to save various results into.

```{r}
resdir <- "results-overall"
dir.create(resdir, showWarning=FALSE)
```

# Detecting highly variable genes across all cells

We fit a trend to the variances of the spike-ins.
This represents the technical variance at any given mean count.
For each endogenous gene, the difference between the technical and total variance is the biological component of variability.
We do this separately for each batch, as there is at least an order of magnitude difference in the amount of spike-in added to each batch.

```{r trendvarfit, fig.height=6, fig.width=10}
par(mfrow=c(1,2))
collected.var <- list()
collected.npcs <- list()
for (b in levels(sce$batch)) {
    cur.sce <- sce[,sce$batch==b]
    cur.sce <- normalize(cur.sce)

    var.fit <- trendVar(cur.sce, method="loess", span=0.4)
    dec.out <- decomposeVar(cur.sce, var.fit)
    collected.var[[b]] <- dec.out
    collected.npcs[[b]] <- denoisePCA(cur.sce, var.fit$trend, value="n")

    plot(dec.out$mean, dec.out$total, pch=16, cex=0.5, col="grey", xlab="Mean log-expression",
         ylab="Variance of log-expression", ylim=c(0, 10), xlim=c(0, 15), main=paste("Batch", b))
    points(var.fit$mean, var.fit$var, pch=16, col="red")
    curve(var.fit$trend(x), col="dodgerblue", add=TRUE, lwd=2)
}
```

The trend passes through the bulk of the spike-ins, which is reassuring.
We combine the statistics across batches (using Berger's IUT to select genes that are HVG in all batches) and save them to file.

```{r combinevar}
var.out <- do.call(combineVar, c(collected.var, method="berger"))
write.table(file=file.path(resdir, "var.tsv"), var.out, sep="\t", quote=FALSE, col.names = NA) 
```

The computed variance can be used to identify highly variable genes, which are subsequently saved to file. 

```{r highvar}
hvg.out <- var.out[which(var.out$FDR <= 0.05 & var.out$bio >= 0.5),]
nrow(hvg.out)
hvg.out <- hvg.out[order(hvg.out$bio, decreasing=TRUE),]
write.table(file = file.path(resdir, "hvg.tsv"), hvg.out, sep="\t", quote=FALSE, col.names = NA) 
head(hvg.out)
```

The most highly variable genes across the whole population are shown to ensure that they are not driven by one or two outliers.

```{r vioplot}
plotExpression(shuffled.sce, rownames(hvg.out)[1:10], alpha=0.5, 
    colour_by="phenotype", jitter="jitter") + fontsize 
```

# Dimensionality reduction based on the technical noise

We examine the lower bound on the number of PCs that should be retained in each data set.
This is based on discarding later PCs until the variance in the discarded PCs is equal to the total technical noise.
Unfortunately, the number of PCs to retain is quite different between the two batches, which is less-than-helpful.

```{r}
unlist(collected.npcs)
```

These differences reflect the fact that the second batch is more biologically noisy, possibly due to the manner in which it was prepared.
We'll use the latter value given that the second batch contains a greater number of cells anyway.

```{r}
chosen.npcs <- collected.npcs[[2]]
```

We apply PCA on the genes with positive biological components in `var.out`.
This mirrors what is done within `denoisePCA`, where only the genes with positive components are used to select the number of PCs.
We do this with the `norm_exprs` expression matrix in which the batch effect has been regressed out (see the pre-processing script for details).

```{r}
keep <- var.out$bio > 0
summary(keep)
pc.out <- prcomp(t(norm_exprs(sce)[keep,,drop=FALSE]), rank=chosen.npcs)
reducedDim(sce, "PCA") <- pc.out$x
dim(reducedDim(sce, "PCA"))
attr(pc.out$x, "percentVar") <- pc.out$sdev^2/sum(pc.out$sdev^2)
```

We save the PCs to file for future use.
We also examine the variance explained by the first few PCs.

```{r}
saveRDS(pc.out$x, file=file.path(resdir, "pcs.rds"))
plot(pc.out)
```

# Visualization in low-dimensional space

We perform dimensionality reduction using _t_-SNE, colouring by various attributes.

```{r tsne, fig.height=10, fig.width=10}
sce <- runTSNE(sce, use_dimred="PCA", perplexity=30, rand_seed=100)
tsne1 <- plotTSNE(sce, colour_by=rownames(hvg.out)[1]) +  fontsize
tsne2 <- plotTSNE(sce, colour_by="KLF4") + fontsize
tsne3 <- plotTSNE(sce, colour_by="batch") + fontsize
tsne4 <- plotTSNE(sce, colour_by="phenotype") + fontsize
multiplot(tsne1, tsne3, tsne2, tsne4, cols=2)
```

We repeat this with PCA, which is simpler but provides more stable results.

```{r pca, fig.height=10, fig.width=10}
pca1 <- plotPCA(sce, colour_by=rownames(hvg.out)[1]) + fontsize
pca2 <- plotPCA(sce, colour_by="KLF4") + fontsize
pca3 <- plotPCA(sce, colour_by="batch") + fontsize 
pca4 <- plotPCA(sce, colour_by="phenotype") + fontsize 
multiplot(pca1, pca3, pca2, pca4, cols=2)
```

# Differential expression analysis

## Testing for differences between naive and primed

Finally, we test for differences in expression between the naive and primed conditions.
This is done using _edgeR_, after summing all cells within each batch to create a pseudo-bulk sample.

```{r desetup}
library(edgeR)
de.counts <- sumTechReps(counts(sce), paste(sce$phenotype, sce$batch, sep="."))
de.counts <- de.counts[!isSpike(sce),] # removing spikes
y <- DGEList(de.counts)
```

We construct a new design matrix for the summed samples.

```{r}
ptype <- factor(sub("\\..", "\\1", colnames(de.counts)))
batch <- factor(sub("^.*\\.", "\\1", colnames(de.counts)))
design_pheno <- model.matrix(~0 + ptype + batch) 
```

We run through _edgeR_'s analysis pipeline. 
We first filter out low-abundance genes, as we did not perform any filtering on `sce` during preprocessing.

```{r}
keep <- aveLogCPM(y) > aveLogCPM(5, mean(y$samples$lib.size))
y <- y[keep,]
summary(keep)
```

First, we normalize the samples using the TMM method.

```{r}
y <- calcNormFactors(y)
y$samples
```

We estimate the negative binomial dispersion, which represents the variability between replicates.
For true bulk RNA-seq experiments, we'd expect BCV values around 0.1 or lower, though the values here will be higher as they are derived from noisier single-cell values.

```{r nbdisp}
y <- estimateDisp(y, design_pheno)  
plotBCV(y)
```

We fit a generalized linear model, with estimates of the quasi-likelihood dispersion to account for gene-specific variability.

```{r qldisp}
fit <- glmQLFit(y, design_pheno, robust=TRUE)
plotQLDisp(fit)
```

Finally, we set up contrasts between the primed and naive population.
We use the QL F-test to test for significant differences in expression.

```{r ftrest}
con <- makeContrasts(ptypenaive - ptypeprimed, levels = design_pheno)
res <- glmQLFTest(fit, contrast=con)
summary(decideTestsDGE(res))
DEmarkers <- topTags(res, n=Inf)$table
write.table(DEmarkers, file=file.path(resdir, "de.tsv"), sep="\t", quote=FALSE, col.names=NA) 
head(DEmarkers)
```

This is shown in more detail using the smear plot below.

```{r smearplot}
is.sig <- DEmarkers$FDR <= 0.05
plotSmear(res, de.tags=rownames(DEmarkers)[is.sig], cex=0.1)
```

To ensure that the top DE genes are not driven by outliers, we can examine them explicitly.

```{r viode}
plotExpression(shuffled.sce, features = rownames(DEmarkers)[1:10], col = "phenotype")
```

## Interpreting the set of DE genes

We use the DE genes for gene set analyses.
First, we take the set of genes that were upregulated in naive over primed.

```{r upgo}
library(GO.db)
library(org.Hs.eg.db)
up.genes <- rownames(DEmarkers)[is.sig & DEmarkers$logFC > 0]
is.up <- rownames(sce) %in% up.genes
entreznames <- as.character(rowData(sce)$entrezgene)
has.entrez <- !is.na(entreznames)
go <- goana(entreznames[has.entrez & is.up], universe=entreznames[has.entrez], species = "Hs")
topgo <- topGO(go, n=Inf, ontology = "BP") 
write.table(file=file.path(resdir, "go_up.tsv"), topgo, sep="\t", quote=FALSE, col.names = NA) 
head(topgo)
```

We repeat the dose for KEGG analyses.

```{r upkegg}
kegg <- kegga(entreznames[has.entrez & is.up], universe=entreznames[has.entrez], species = "Hs")
topkegg <- topKEGG(kegg, n=Inf)
write.table(file=file.path(resdir, "kegg_up.tsv"), topkegg, sep="\t", quote=FALSE, col.names = NA) 
head(topkegg)
```

We now turn our attention to the downregulated genes, i.e., those expressed in primed and not naive.

```{r downgo}
down.genes <- rownames(DEmarkers)[is.sig & DEmarkers$logFC < 0]
is.down <- rownames(sce) %in% down.genes
go <- goana(entreznames[has.entrez & is.down], universe=entreznames[has.entrez], species = "Hs")
topgo <- topGO(go, n=Inf, ontology = "BP") 
write.table(file=file.path(resdir, "go_down.tsv"), topgo, sep="\t", quote=FALSE, col.names = NA) 
head(topgo)
```

We repeat for KEGG analyses.

```{r downkegg}
kegg <- kegga(entreznames[has.entrez & is.down], universe=entreznames[has.entrez], species = "Hs")
topkegg <- topKEGG(kegg, n=Inf)
write.table(file=file.path(resdir, "kegg_down.tsv"), topkegg, sep="\t", quote=FALSE, col.names = NA) 
head(topkegg)
```

# Wrapping up

There's nothing else to save, so we just report the session information here.

```{r}
sessionInfo()
```
