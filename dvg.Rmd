---
title: "Single-cell RNA-seq of naive/primed embryonic stem cells: differential variability" 
author: Tobias Messmer and Aaron Lun
date: 13 November 2017
output: 
  html_document:
    toc: true
    toc_float: true
    depth: 3
    number_sections: true
    theme: united 
    highlight: tango 
    fig_caption: false
---

```{r, echo=FALSE, results="hide"}
dir.create("figure-dvg/", showWarning=FALSE)
knitr::opts_chunk$set(error=FALSE, warning=FALSE, message=FALSE, fig.path="figure-dvg/")
options(bitmapType="cairo", width=100)
library(BiocParallel)
register(SerialParam())
```

# Overview

The idea here is to test for whether there are any changes in variability between the naive and primed populations.
This will allow us to determine if the primed population is getting noisier, e.g., in preparation for differentiation into the three germ layers.
First, we load in the counts for each cell.
We identify the transition cells in the naive population to prune them out.
This ensures that we're estimating the dispersion for homogeneous populations.

```{r}
library(scran)
sce <- readRDS("sce_all.rds")
true.groups <- read.table("results-naive/groups.tsv", header=TRUE, stringsAsFactors=FALSE)
sce <- sce[,true.groups$Type[match(colnames(sce), true.groups$Cell)]!="transition"]
```

We also set up an output directory.

```{r}
resdir <- "results-dvg"
dir.create(resdir, showWarning=FALSE)
```

# Using the NB dispersions

## Estimating the dispersions

We can use the NB dispersion as a measure of the variability of expression for each gene in each sample.
We use _edgeR_ to estimate the dispersion for each sample.
This gives us biological components after we take the residual from the technical trend (fitted based on spike-in counts).

```{r, fig.height=10, fig.width=10}
source("~/Documents/Studium/Master/2016-10 Cambridge/NaiveHESC2016/testing/varfun.R")
bio.mat <- weight.mat <- matrix(0, nrow(sce), nlevels(sce$sample))
colnames(bio.mat) <- colnames(weight.mat) <- levels(sce$sample)

par(mfrow=c(2,2))
for (s in levels(sce$sample)) {
    chosen <- sce$sample==s 
    design <- matrix(1, sum(chosen), 1)
    current <- getBioDisp(counts(sce)[,chosen,drop=FALSE], design, 
        is.spike=isSpike(sce, "ERCC"), sf.cell=sizeFactors(sce)[chosen],
        sf.spike=sizeFactors(sce, "ERCC")[chosen], plot=TRUE, niters=0)
    bio.mat[,s] <- current$bio
    weight.mat[,s] <- nrow(design) - ncol(design)
}
```

We set this up as a `EList` with weight components.
We use the Ensembl Gene IDs for naming to make it  easier later on to match to pre-defined gene sets.

```{r}
library(limma)
vals <- new("EList", list(E=bio.mat, weights=weight.mat))
rownames(vals) <- rowData(sce)$ensembl_gene_id
```

We filter out genes with negative average components or low abundances.

```{r}
library(scater)
ab <- calcAverage(sce)
keep <- rowMeans(bio.mat) > 0 & ab > 5
vals <- vals[keep,]
summary(keep)
``` 

We have a preview of the component matrix.

```{r}
head(bio.mat)
```

## Testing for differential variability

We set up a design matrix with an additive model.

```{r}
condition <- rep(c("naive", "primed"), 2)
batch <- factor(c(1,1,2,2))
design <- model.matrix(~batch + condition)
design
```

We apply _limma_ to fit a linear model to the biological components.
We see some evidence for a trend at low-abundances so we set `trend=TRUE`. 
This requires some hacking to replace the mean components with the actual abundances.

```{r, fig.width=12, fig.height=6}
fit <- lmFit(vals, design)
fit$genes <- data.frame(Symbol=rowData(sce)$external_gene_name[keep])
fit$Amean <- log2(rowData(sce)$AveCount[keep])
fit <- eBayes(fit, robust=TRUE, trend=TRUE)
summary(fit$df.prior)
par(mfrow=c(1,2))
plotSA(fit)
plotSA(fit, log="x")
```

We proceed to have a look at the differentially variable genes at a FDR of 5%.

```{r}
summary(decideTests(fit))
all.dvg <- topTable(fit, coef=ncol(design), n=Inf, sort.by="p")
gzout <- gzfile(file.path(resdir, "dvg_nbdisp.tsv.gz"), open="wb")
write.table(file=gzout, all.dvg, sep="\t", quote=FALSE, col.names=NA)
close(gzout)
head(all.dvg)
```

We can examine the top hits in more detail.
Changes in variability between conditions are mostly driven by differential expression, as one might expect.

```{r}
matching <- rownames(sce)[rowData(sce)$ensembl_gene_id %in% rownames(all.dvg)[1:4]]
plotExpression(sce, features=matching, x="sample", colour_by="phenotype")
```

## Examining DV in germ layer markers

We throw ROAST at the gene set used to characterize each germ layer (curated by Ferdinand).

```{r}
by.lineage <- read.table("~/Documents/Studium/Master/2016-10 Cambridge/NaiveHESC2016/miscellaneous/commit_lineages.tsv", header=TRUE, stringsAsFactors=FALSE)
endo.set <- by.lineage$Symbol[grep("endoderm", by.lineage$Germ_layer)]
head(endo.set)
ecto.set <- by.lineage$Symbol[grep("ectoderm", by.lineage$Germ_layer)]
head(ecto.set)
meso.set <- by.lineage$Symbol[grep("mesoderm", by.lineage$Germ_layer)]
head(meso.set)
```

Setting up a function to identify the surviving genes.

```{r}
library(org.Hs.eg.db)
inPresentSet <- function(present, desired) {
    ensembls <- mapIds(org.Hs.eg.db, keytype="SYMBOL", keys=desired, column="ENSEMBL")
    which(present %in% ensembls)    
}
```

Checking whether there's evidence for an increase in variability in the primed condition (`Up`) in the gene sets defining each germ layer.

```{r}
endo.keep <- inPresentSet(rownames(vals), endo.set)
roast(vals, index=endo.keep, design=design, coef=ncol(design)) 
ecto.keep <- inPresentSet(rownames(vals), ecto.set)
roast(vals, index=ecto.keep, design=design, coef=ncol(design)) 
meso.keep <- inPresentSet(rownames(vals), meso.set)
roast(vals, index=meso.keep, design=design, coef=ncol(design)) 
```

```{r, echo=FALSE, results="hide"}
gc()
```

# Using the variance of log-expression

## Estimating the biological components

We cycle through each sample, fit a curve and extract the biological components as well as the mean expression for each gene.
Calculating the variance of the log-expression values has the advantage in that it does not need to be interpreted with respect to the mean.
In contrast, the dispersion only makes sense as a measure of variance when considered with the mean.

```{r}
collected.bio <- collected.tech <- collected.mean <- collected.weight <- list()
for (s in levels(sce$sample)) {
    cur.sce <- sce[,s==sce$sample]
    cur.sce <- normalize(cur.sce)

    var.fit <- trendVar(cur.sce, method="loess", span=0.4)
    var.out <- decomposeVar(cur.sce, var.fit)
    collected.bio[[s]] <- var.out$bio
    collected.mean[[s]] <- var.out$mean
    collected.tech[[s]] <- var.out$tech
    collected.weight[[s]] <- rep(nrow(var.fit$design) - ncol(var.fit$design), nrow(var.out))
}
bio.mat <- do.call(cbind, collected.bio)
mean.mat <- do.call(cbind, collected.mean)
weight.mat <- do.call(cbind, collected.weight)
vals <- new("EList", list(E=bio.mat, weights=weight.mat))
rownames(vals) <- rowData(sce)$ensembl_gene_id
vals
```

We filter out genes that have negative average biological components or low abundances.

```{r}
weighted.ab <- rowSums(mean.mat * weight.mat)/rowSums(weight.mat)
weighted.bio <- rowSums(bio.mat * weight.mat)/rowSums(weight.mat)
keep <- weighted.ab > 1 & weighted.bio > 0
vals <- vals[keep,]
summary(keep)
```

## Diagnostic plots

We've assumed that subtraction of the trend was sufficient to account for technical noise.
This is not entirely true as elevated technical noise can also result in scaling of the variance estimates.
Inflation of the estimates of the biological components between samples would subsequently result in spurious DV.
Here, there are clearly differences in the trends between samples, which could lead to scaling effects.

```{r}
plot(collected.mean[[1]], collected.tech[[1]], col="lightblue", pch=16, 
    ylim=c(0, 9), xlab="Mean", ylab="Technical variance")
points(collected.mean[[2]], collected.tech[[2]], col="blue", pch=16)
points(collected.mean[[3]], collected.tech[[3]], col="salmon", pch=16)
points(collected.mean[[4]], collected.tech[[4]], col="red", pch=16)
```

To check this, we plot the biological components against each other for samples from the same batch.
Any scaling should manifest as a clear diagonal line with a gradient that differs from unity.
We don't observe this, which is fortunate.

```{r, fig.width=12, fig.height=6}
par(mfrow=c(1,2))
smoothScatter(vals$E[,1], vals$E[,3], main="Batch 1", xlab="Bio (naive)", ylab="Bio (primed)")
abline(a=0, b=1, col="red", lwd=0.5)
smoothScatter(vals$E[,2], vals$E[,4], main="Batch 2", xlab="Bio (naive)", ylab="Bio (primed)")
abline(a=0, b=1, col="red", lwd=0.5)
```

## Hypothesis testing for differential variability

We re-use the design matrix from before, and we apply _limma_ to fit a linear model to the biological components.
Again, some hacking is required to get the trend with respect to abundance.

```{r, fig.width=12, fig.height=6}
fit <- lmFit(vals, design)
fit$genes <- data.frame(Symbol=rowData(sce)$external_gene_name[keep])
fit$Amean <- weighted.ab[keep]
fit <- eBayes(fit, robust=TRUE, trend=TRUE)
summary(fit$df.prior)
par(mfrow=c(1,2))
plotSA(fit)
plotSA(fit, log="x")
```

We look at the differentially variable genes at a FDR of 5%.

```{r}
summary(decideTests(fit))
all.dvg <- topTable(fit, coef=ncol(design), n=Inf, sort.by="p")
gzout <- gzfile(file.path(resdir, "dvg_logvar.tsv.gz"), open="wb")
write.table(file=gzout, all.dvg, sep="\t", quote=FALSE, col.names=NA)
close(gzout)
head(all.dvg)
```

And we can examine the top hits in more detail.

```{r}
matching <- rownames(sce)[rowData(sce)$ensembl_gene_id %in% rownames(all.dvg)[1:4]]
plotExpression(sce, features=matching, x="sample", colour_by="phenotype")
```

## Examining specific gene sets

We throw ROAST at the germ layer-specific gene sets.

```{r}
endo.keep <- inPresentSet(rownames(vals), endo.set)
roast(vals, index=endo.keep, design=design, coef=ncol(design)) 
ecto.keep <- inPresentSet(rownames(vals), ecto.set)
roast(vals, index=ecto.keep, design=design, coef=ncol(design)) 
meso.keep <- inPresentSet(rownames(vals), meso.set)
roast(vals, index=meso.keep, design=design, coef=ncol(design)) 
```

We have a look at the genes that are more variable in primed cells.

```{r}
entreznames <- as.character(rowData(sce)$entrezgene)
has.entrez <- !is.na(entreznames)
all.tested <- rownames(all.dvg)
in.universe <- entreznames[rowData(sce)$ensembl_gene_id %in% all.tested & has.entrez]

dvg.in.primed <- rownames(all.dvg)[all.dvg$adj.P.Val <= 0.05 & all.dvg$logFC > 0]
in.primed <- entreznames[rowData(sce)$ensembl_gene_id %in% dvg.in.primed & has.entrez]

go <- goana(in.primed, universe=in.universe, species="Hs")
topgo <- topGO(go, n=Inf, ontology = "BP") 
write.table(file=file.path(resdir, "go_dvg_primed.tsv"), topgo, sep="\t", quote=FALSE, col.names = NA) 
head(topgo)

kegg <- kegga(in.primed, universe=in.universe, species="Hs")
topkegg <- topKEGG(kegg, n=Inf)
write.table(file=file.path(resdir, "kegg_dvg_primed.tsv"), topkegg, sep="\t", quote=FALSE, col.names = NA) 
head(topkegg)
```

Repeating the dose for DVGs that go in the other direction.

```{r}
dvg.in.naive <- rownames(all.dvg)[all.dvg$adj.P.Val <= 0.05 & all.dvg$logFC < 0]
in.naive <- entreznames[rowData(sce)$ensembl_gene_id %in% dvg.in.naive & has.entrez]

go <- goana(in.naive, universe=in.universe, species="Hs")
topgo <- topGO(go, n=Inf, ontology = "BP") 
write.table(file=file.path(resdir, "go_dvg_naive.tsv"), topgo, sep="\t", quote=FALSE, col.names = NA) 
head(topgo)

kegg <- kegga(in.naive, universe=in.universe, species="Hs")
topkegg <- topKEGG(kegg, n=Inf)
write.table(file=file.path(resdir, "kegg_dvg_naive.tsv"), topkegg, sep="\t", quote=FALSE, col.names = NA) 
head(topkegg)
```

# Differential expression of specific markers

The idea of this section is to assess whether DE genes between the naive and primed subpopulation include markers for specific germ layers.
For this, we import the DE genes and the marker lists.

```{r}
DEgenes <- read.table(file=file.path('results-overall','de.tsv'))

markers <- read.csv("~/Documents/Studium/Master/2016-10 Cambridge/NaiveHESC2016/miscellaneous/ferd_marker_set.csv", stringsAsFactors = FALSE, header = FALSE)
chosen_markers <- inPresentSet(rowData(sce)$ensembl_gene_id, markers[,1])

#germlayers
endo_markers <- inPresentSet(rowData(sce)$ensembl_gene_id, endo.set)
ecto_markers <- inPresentSet(rowData(sce)$ensembl_gene_id, ecto.set)
meso_markers <- inPresentSet(rowData(sce)$ensembl_gene_id, meso.set)

naive.hvg <- read.table(file=file.path('results-naive','hvg.tsv'), header=TRUE, stringsAsFactors=FALSE)
primed.hvg <- read.table(file=file.path('results-primed','hvg.tsv'), header=TRUE, stringsAsFactors=FALSE)
```

First, we visualize the primed population to check whether it forms any clusters and color the PCA/tSNE according to their expression of the most highly variable gene.

```{r}
fontsize <- theme(axis.text=element_text(size=12), axis.title=element_text(size=16), title = element_text(size=12))

plotPCA(sce[,sce$phenotype == 'primed'], exprs_values="norm_exprs", colour_by = rownames(primed.hvg[1,]), rerun=T) + fontsize
plotTSNE(sce[,sce$phenotype == 'primed'], exprs_values="norm_exprs", colour_by=rownames(primed.hvg[1,]),  rerun=T,
    perplexity=5, rand_seed=100) + fontsize
```

If cell-cycle related genes colour different clusters/parts of the PCA/tSNE, this is an indication that cell-cycle is the major driver for heterogeneity. However, we want to further assess whether clusters form if we only use genes that are specific for the respective germlayers.

```{r}

pca_primed <- plotPCA(sce[,sce$phenotype == 'primed'], exprs_values="norm_exprs", colour_by = 'GATA4', feature_set = rownames(sce)[endo_markers], rerun=T) + fontsize
pca_naive <- plotPCA(sce[,sce$phenotype == 'naive'], exprs_values="norm_exprs", colour_by = 'GATA4', feature_set = rownames(sce)[endo_markers], rerun=T) + fontsize
multiplot(pca_primed, pca_naive, cols=2)

pca_primed <- plotPCA(sce[,sce$phenotype == 'primed'], exprs_values="norm_exprs", colour_by = 'FGF5', feature_set = rownames(sce)[ecto_markers], rerun=T) + fontsize
pca_naive <- plotPCA(sce[,sce$phenotype == 'naive'], exprs_values="norm_exprs", colour_by = 'FGF5', feature_set = rownames(sce)[ecto_markers], rerun=T) + fontsize
multiplot(pca_primed, pca_naive, cols=2)

pca_primed <- plotPCA(sce[,sce$phenotype == 'primed'], exprs_values="norm_exprs", colour_by = 'T', feature_set = rownames(sce)[meso_markers], rerun=T) + fontsize
pca_naive <- plotPCA(sce[,sce$phenotype == 'naive'], exprs_values="norm_exprs", colour_by = 'T', feature_set = rownames(sce)[meso_markers], rerun=T) + fontsize
multiplot(pca_primed, pca_naive, cols=2)

germlayers <- c(rownames(sce)[meso_markers], rownames(sce)[endo_markers], rownames(sce)[ecto_markers])
pca_primed <- plotPCA(sce[,sce$phenotype == 'primed'], exprs_values="norm_exprs", colour_by = "CDK1", feature_set = germlayers) + fontsize
pca_naive <- plotPCA(sce[,sce$phenotype == 'naive'], exprs_values="norm_exprs", colour_by = "CDK1", feature_set = germlayers) + fontsize
multiplot(pca_primed, pca_naive, cols=2)

```


```{r}
pca_primed <- plotPCA(sce[,sce$phenotype == 'primed'], exprs_values="norm_exprs", colour_by = 'GATA4', feature_set = rownames(sce)[c(endo_markers, ecto_markers, meso_markers)], rerun=T) + fontsize
pca_naive <- plotPCA(sce[,sce$phenotype == 'naive'], exprs_values="norm_exprs", colour_by = 'GATA4', feature_set = rownames(sce)[c(endo_markers, ecto_markers, meso_markers)], rerun=T) + fontsize
multiplot(pca_primed, pca_naive, cols=2)
```

Finally, we can also check what happens if we only use DE genes between naive and primed for clustering.

```{r}
plotPCA(sce[,sce$phenotype == 'primed'], exprs_values="norm_exprs", colour_by = "SFRP2", feature_set = rownames(DEgenes[DEgenes$FDR<0.05,])) + fontsize
plotPCA(sce[,sce$phenotype == 'naive'], exprs_values="norm_exprs", colour_by = rownames(DEgenes[1,]), feature_set = rownames(DEgenes[DEgenes$FDR<0.05,])) + fontsize
```

Next, we focus on the genes that are differentially expressed between naive and primed. We check whether they are in the list of DE genes and if yes, whether they are signifcantly different (FDR <0.05) and whether we consider the change biologically relevant (logFC > 1).

```{r}
par(mfrow=c(3,1))
length(endo_markers)
sum(rownames(DEgenes) %in% rownames(sce)[endo_markers])
DE_endo <- DEgenes[which(rownames(DEgenes) %in% rownames(sce)[endo_markers]),]
primed_up_endo <- DE_endo[DE_endo$FDR <= 0.05 & DE_endo$logFC > 1,]
primed_down_endo <- DE_endo[DE_endo$FDR <= 0.05 & DE_endo$logFC < -1,]
result.endo <- data.frame(primed_up = dim(primed_up_endo)[1], primed_down = dim(primed_down_endo)[1], irrelevant = sum(DE_endo$FDR > 0.05), row.names = 'gene count')
barplot(t(matrix(result.endo)), names.arg = colnames(result.endo), main='endoderm', ylim = c(0,40))

length(ecto_markers)
sum(rownames(DEgenes) %in% rownames(sce)[ecto_markers])
DE_ecto <- DEgenes[which(rownames(DEgenes) %in% rownames(sce)[ecto_markers]),]
primed_up_ecto <- DE_ecto[DE_ecto$FDR <= 0.05 & DE_ecto$logFC > 1,]
primed_down_ecto <- DE_ecto[DE_ecto$FDR <= 0.05 & DE_ecto$logFC < -1,]
result.ecto <- data.frame(primed_up = dim(primed_up_ecto)[1], primed_down = dim(primed_down_ecto)[1], irrelevant = sum(DE_ecto$FDR > 0.05), row.names = 'gene count')
barplot(t(matrix(result.ecto)), names.arg = colnames(result.endo), main='ectoderm', ylim = c(0,40))

length(meso_markers)
sum(rownames(DEgenes) %in% rownames(sce)[meso_markers])
DE_meso <- DEgenes[which(rownames(DEgenes) %in% rownames(sce)[meso_markers]),]
primed_up_meso <- DE_meso[DE_meso$FDR <= 0.05 & DE_meso$logFC > 1,]
primed_down_meso <- DE_endo[DE_meso$FDR <= 0.05 & DE_meso$logFC < -1,]
result.meso <- data.frame(primed_up = dim(primed_up_meso)[1], primed_down = dim(primed_down_meso)[1], irrelevant = sum(DE_meso$FDR > 0.05) , row.names = 'gene count')
barplot(t(matrix(result.endo)), names.arg = colnames(result.meso), main='mesoderm', ylim = c(0,40))
```

We can do the same for the naive and primed subset, respectively by using the highly variable genes in each subpopulation.

```{r}
par(mfrow=c(2,1))
result_naive <- matrix(1, nrow=2, ncol=3)

print('naive hvg vs endoderm')
result_naive[1,1] <- length(endo_markers)
result_naive[2,1] <- sum(rownames(naive.hvg) %in% rownames(sce)[endo_markers])
naive.hvg_endo <- naive.hvg[which(rownames(naive.hvg) %in% rownames(sce)[endo_markers]),]


print('naive hvg vs ectoderm')
result_naive[1,2] <- length(ecto_markers)
result_naive[1,2] <- sum(rownames(naive.hvg) %in% rownames(sce)[ecto_markers])
naive.hvg_ecto <- naive.hvg[which(rownames(naive.hvg) %in% rownames(sce)[ecto_markers]),]


print('naive hvg vs mesoderm')
result_naive[1,3] <- length(meso_markers)
result_naive[1,3] <- sum(rownames(naive.hvg) %in% rownames(sce)[meso_markers])
naive.hvg_meso <- naive.hvg[which(rownames(naive.hvg) %in% rownames(sce)[meso_markers]),]
barplot(result_naive, names.arg = c('endo', 'ecto', 'meso'), main = 'naive hvgs', legend=c('total','hvg'), beside=T)

result_primed <- matrix(1, nrow=2, ncol=3)

result_primed[1,1] <- length(endo_markers)
result_primed[2,1] <- sum(rownames(primed.hvg) %in% rownames(sce)[endo_markers])
primed.hvg_endo <- primed.hvg[which(rownames(primed.hvg) %in% rownames(sce)[endo_markers]),]


result_primed[1,2] <- length(ecto_markers)
result_primed[2,2] <- sum(rownames(primed.hvg) %in% rownames(sce)[ecto_markers])
primed.hvg_ecto <- primed.hvg[which(rownames(primed.hvg) %in% rownames(sce)[ecto_markers]),]


result_primed[1,3] <- length(meso_markers)
result_primed[2,3] <- sum(rownames(naive.hvg) %in% rownames(sce)[meso_markers])
primed.hvg_meso <- primed.hvg[which(rownames(naive.hvg) %in% rownames(sce)[meso_markers]),]

barplot(result_primed, names.arg = c('endo', 'ecto', 'meso'), main = 'primed hvgs', legend=c('total','hvg'), beside=T)
```

# Wrapping up

```{r}
sessionInfo()
```
