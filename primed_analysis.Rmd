---
title: "Single-cell RNA-seq of naive/primed embryonic stem cells: primed-only analysis"
author: Tobias Messmer and Aaron Lun
date: 13 November 2017
output: 
  html_document:
    toc: true
    toc_float: true
    depth: 3
    number_sections: true
    theme: united 
    highlight: tango 
    fig_caption: false
---

```{r, echo=FALSE, results="hide"}
dir.create("figure-primed/", showWarning=FALSE)
knitr::opts_chunk$set(error=FALSE, warning=FALSE, message=FALSE, fig.path="figure-primed/")
options(bitmapType="cairo", width=100)
library(BiocParallel)
register(SerialParam())
```

# Selecting only the primed subpopulations

We select only the primed cells and attempt to identify subpopulations within the primed condition.
This is more sensitive than doing so on the entire data set, where the naive/primed differences dominate.

```{r primedin}
library(scran)
sce <- readRDS("sce_all.rds")
sce_primed <- sce[,colData(sce)$phenotype=="primed"] 
dim(sce_primed)
```

We adjust the `batch` factor to get rid of the now-unnecessary "naive" level. 
We also re-normalize to rescale the size factors at unity, so that they are comparable between spike-ins and endogenous genes.

```{r}
sce_primed$batch <- factor(sce_primed$batch)
sce_primed <- normalize(sce_primed)
```

We can examine the expression of the various ESC markers in more detail.

```{r primedExpMarker}
library(scater)
fontsize <- theme(axis.text=element_text(size=12), axis.title=element_text(size=16))
plotExpression(sce_primed, c("KLF4", "KLF17", "DPPA3", "TFCP2L1", "NANOG", "ZFP42", "POU5F1"),
    colour_by="batch") + fontsize
```

We also set up an output directory for the results.

```{r primedout}
resdir <- "results-primed"
dir.create(resdir, showWarning=FALSE)
```

# Detecting primed-only HVGs

We detect HVGs in the primed population, using the variance of the normalized log-expression values.
A trend is fitted to the spike-in variances and represents the technical aspect of variability.
This is done separately for each batch due to the differences in spike-in quantity.
The trend is okay, though some deviation of the spike-ins is attributable to amplification-induced variability.

```{r primed.vartrend, fig.height=6, fig.width=10}
par(mfrow=c(1,2))
collected.var_primed <- list()
collected.npcs_primed <-list()
for (b in levels(sce_primed$batch)) {
    cur.sce <- sce_primed[,b==sce_primed$batch]
    cur.sce <- normalize(cur.sce)
    
    var.fit <- trendVar(cur.sce, method="loess", span=0.4)
    var.out <- decomposeVar(cur.sce, var.fit)
    collected.var_primed[[b]] <- var.out 
    collected.npcs_primed[[b]] <- denoisePCA(cur.sce, var.fit$trend, value="n")
    
    # Saving output as a compressed GZip file.
    gzout <- gzfile(file.path(resdir, sprintf("var_%s.tsv.gz", b)), open="wb")
    write.table(file=gzout, var.out, sep="\t", quote=FALSE, col.names=NA)
    close(gzout)
    
    plot(var.out$mean, var.out$total, pch=16, cex=0.6, xlab="Mean log-expression",
        ylab="Variance of log-expression", main=paste("Batch", b), col="grey")
    points(var.fit$mean, var.fit$var, pch=16, col="red")
    curve(var.fit$trend(x), col="red", add=TRUE, lwd=2)
}
```

We combine statistics across batches (requiring a gene to be HVG in both batches in order to be detected) and save them to file.

```{r primed.varplot}
var.out_primed <- do.call(combineVar, collected.var_primed)
gzout <- gzfile(file.path(resdir, "var_all.tsv.gz"), open="wb")
write.table(file=gzout, var.out_primed, sep="\t", quote=FALSE, col.names=NA) 
close(gzout)
```

Genes with significantly non-zero biological components at a FDR of 5% are defined as HVGs.

```{r var.primed}
hvg.out_primed <- var.out_primed[which(var.out_primed$FDR <= 0.05 & var.out_primed$bio >= 0.5),]
hvg.out_primed <- hvg.out_primed[order(hvg.out_primed$bio, decreasing=TRUE),]
nrow(hvg.out_primed)
gzout <- gzfile(file.path(resdir, "hvg.tsv.gz"), open="wb")
write.table(file=gzout, hvg.out_primed, sep="\t", quote=FALSE, col.names = NA) 
close(gzout)
head(hvg.out_primed)
```

We check that the HVGs are not being driven by outliers or batch effects.

```{r violin.hvg}
plotExpression(sce_primed, rownames(hvg.out_primed)[1:10], alpha=0.05, 
    colour_by="batch", jitter="jitter") + fontsize
```

# Performing dimensionality reduction

We remove the batch effect prior to performing dimensionality reduction.
This needs to be repeated as the batch effect for the primed-only cells may be different from the batch effect of the entire data set.

```{r}
library(limma)
norm_exprs(sce_primed) <- removeBatchEffect(exprs(sce_primed), batch=sce_primed$batch) 
```

We examine the lower bound on the number of PCs that should be retained in each data set.
Again, the number of PCs to retain is quite different between the two batches, which is annoying.

```{r}
unlist(collected.npcs_primed)
```

We'll use the latter value given that the second batch contains a greater number of cells anyway.

```{r}
chosen.npcs_primed <- collected.npcs_primed[[2]]
```

We apply PCA on the genes with positive biological components in `var.out_primed`.
This is done using the `norm_exprs` expression matrix in which the batch effect has been regressed out. 

```{r}
keep <- var.out_primed$bio > 0
summary(keep)
pc.out <- prcomp(t(assay(sce_primed, "norm_exprs")[keep,,drop=FALSE]), rank=chosen.npcs_primed)
reducedDim(sce_primed, "PCA") <- pc.out$x
dim(reducedDim(sce_primed, "PCA"))
plot(pc.out)
```

# Visualization in low-dimensional space

We then create _t_-SNE plots, using only the set of correlated HVGs.

```{r tsne.primed, fig.width=15, fig.height=6}
sce_primed <- runTSNE(sce_primed, use_dimred="PCA", perplexity=10, rand_seed=100)
tsne1_primed <- plotTSNE(sce_primed, colour_by=rownames(hvg.out_primed)[1]) +  fontsize
tsne2_primed <- plotTSNE(sce_primed, colour_by="KLF4") + fontsize
tsne3_primed <- plotTSNE(sce_primed, colour_by="batch") + fontsize
multiplot(tsne1_primed, tsne2_primed, tsne3_primed, cols=3)
```

And again, for PCA plots.

```{r pca.primed, fig.width=15, fig.height=6}
pca1_primed <- plotPCA(sce_primed, colour_by=rownames(hvg.out_primed)[1]) + fontsize
pca2_primed <- plotPCA(sce_primed, colour_by="KLF4") + fontsize
pca3_primed <- plotPCA(sce_primed, colour_by="batch") + fontsize
multiplot(pca1_primed, pca2_primed, pca3_primed, cols=3)
```

Both plots suggest that there is a small subpopulation off the main bulk of cells.

# Clustering to identify putative subpopulations

We perform hierarchical clustering on the Euclidean distance in the PC space.

```{r primedclust}
pcs_primed <- reducedDim(sce_primed, "PCA")
my.dist_primed <- dist(pcs_primed)
my.tree_primed <- hclust(my.dist_primed)
```

To identify the "best" number of clusters, we vary the `k` for tree cutting and examine the resulting silhouette plots.
There's not much evidence for clear separation of the clusters at any `k`.
Many clusters have cells have negative widths that should be allocated to other clusters, indicating that the separation of cells here is quite weak.
As such, we do not perform any clustering.

```{r silhouette, fig.width=10, fig.height=10}
library(cluster)
par(mfrow=c(2,2))
for (k in 2:5){
    my.clusters_primed <- unname(cutree(my.tree_primed, k=k))
    col <- rainbow(k)
    sil <- silhouette(my.clusters_primed, dist = my.dist_primed)
    sil.cols <- col[ifelse(sil[,3] > 0, sil[,1], sil[,2])]
    sil.cols <- sil.cols[order(-sil[,1], sil[,3])]
    plot(sil, main = paste(k, "clusters"), border=sil.cols, 
        col=sil.cols, do.col.sort=FALSE)
}
```

# Comparison of subpopulation heterogeneity

## Overall changes between naive and primed conditions

We compare the variability of the naive and primed populations to each other.
We first look at the number of HVGs detected in each population.

```{r}
var.out_naive <- read.table(file.path("results-naive", "var_all.tsv.gz"))
hvg.out_naive <- read.table(file.path("results-naive", "hvg.tsv.gz"))
nrow(hvg.out_primed)
nrow(hvg.out_naive)
```

The number is slightly lower in the primed population, though that's probably due to loss of power from increases in the technical variance.
For example, the primed population (blue) has greater variability in the spike-in counts.

```{r}
plot(var.out_primed$mean, var.out_primed$tech, col="dodgerblue", pch=16, cex=0.5,
    xlab="Mean log-expression", ylab="Technical variance")
points(var.out_naive$mean, var.out_naive$tech, col="orange", pch=16, cex=0.5)
```

We also have a look at the biological components.
A naive examination of the biological components of the HVGs suggests that the primed population is more variable.

```{r}
boxplot(list(Primed=hvg.out_primed$bio, Naive=hvg.out_naive$bio), 
    ylab="Biological component", ylim=c(0, 5), col=c("dodgerblue", "orange"))
```

Unfortunately, this seems to be just due to the greater imprecision of the variance estimate in primed cells.
For example, it seems that the lowly variable genes have smaller biological components in the primed condition as well.

```{r}
lvg_naive <- order(var.out_naive$bio)[1:1000]
lvg_primed <- order(var.out_primed$bio)[1:1000]
boxplot(list(Primed=var.out_primed$bio[lvg_primed], 
             Naive=var.out_naive$bio[lvg_naive]), 
    ylab="Biological component", col=c("dodgerblue", "orange"))
```

## Testing each gene for differential variability

### Data loading

We proceed to test for significant differences in the biological components.
This exploits the fact that we have two batches, which allows us to model the variability in the variance estimates.

```{r}
naive_1 <- read.table("results-naive/var_1.tsv.gz", header=TRUE, row.names=1)
naive_2 <- read.table("results-naive/var_2.tsv.gz", header=TRUE, row.names=1)
primed_1 <- read.table("results-primed/var_1.tsv.gz", header=TRUE, row.names=1)
primed_2 <- read.table("results-primed/var_2.tsv.gz", header=TRUE, row.names=1)
stopifnot(identical(rownames(sce), rownames(naive_1)))
stopifnot(identical(rownames(sce), rownames(naive_2)))
stopifnot(identical(rownames(sce), rownames(primed_1)))
stopifnot(identical(rownames(sce), rownames(primed_2)))
bio.tab <- cbind(naive_1$bio, naive_2$bio, primed_1$bio, primed_2$bio)
rownames(bio.tab) <- rowData(sce)$ensembl_gene_id
head(bio.tab)
```

We filter out low-abundance genes first as they have very high variability in the ratio of the variance estimates to the mean, which distorts the prior d.f. estimates.
This requires knowledge of the actual mean, which is _not_ the same as `rowMeans(bio.tab)`!
We also filter out genes that have negative average components or that are spike-in transcripts.

```{r}
ab <- rowMeans(exprs(sce))
keep <- ab > 1 & rowMeans(bio.tab) > 0 & !isSpike(sce)
bio.tab2 <- bio.tab[keep,]
summary(keep)
```

### Diagnostic plots

We've assumed that subtraction of the trend was sufficient to account for technical noise.
This is not entirely true as elevated technical noise can also result in scaling of the variance estimates.
Inflation of the estimates of the biological components between samples would subsequently result in spurious DV.
Here, there are clearly differences in the trends between samples, which could lead to scaling effects.

```{r}
plot(naive_1$mean, naive_1$tech, col="lightblue", pch=16, 
    ylim=c(0, 10), xlab="Mean", ylab="Technical variance")
points(naive_2$mean, naive_2$tech, col="blue", pch=16)
points(primed_1$mean, primed_1$tech, col="salmon", pch=16)
points(primed_2$mean, primed_2$tech, col="red", pch=16)
```

To check this, we plot the biological components against each other for samples from the same batch.
Any scaling should manifest as a clear diagonal line with a gradient that differs from unity.
We don't observe this, which is fortunate.

```{r, fig.width=12, fig.height=6}
par(mfrow=c(1,2))
smoothScatter(bio.tab2[,1], bio.tab2[,3], main="Batch 1", xlab="Bio (naive)", ylab="Bio (primed)")
abline(a=0, b=1, col="red", lwd=0.5)
smoothScatter(bio.tab2[,2], bio.tab2[,4], main="Batch 2", xlab="Bio (naive)", ylab="Bio (primed)")
abline(a=0, b=1, col="red", lwd=0.5)
```

### Hypothesis testing for differential variability

We set up a design matrix with an additive model.

```{r}
condition <- rep(c("naive", "primed"), each=2)
batch <- factor(c(1,2,1,2))
design <- model.matrix(~batch + condition)
design
```

We then apply _limma_ to fit a linear model to the biological components.
We see some evidence for a trend at low-abundances so we set `trend=TRUE`. 
This requires some hacking to replace the mean components with the actual abundances.

```{r, fig.width=12, fig.height=6}
fit <- lmFit(bio.tab2, design)
fit$genes <- data.frame(Symbol=rowData(sce)$external_gene_name[keep])
fit$Amean <- ab[keep]
fit <- eBayes(fit, robust=TRUE, trend=TRUE)
summary(fit$df.prior)
par(mfrow=c(1,2))
plotSA(fit)
plotSA(fit, log="x")
```

We then proceed to have a look at the differentially variable genes at a FDR of 5%.

```{r}
summary(decideTests(fit))
all.dvg <- topTable(fit, coef=ncol(design), n=Inf, sort.by="p")
gzout <- gzfile(file.path(resdir, "dvg.tsv.gz"), open="wb")
write.table(file=gzout, all.dvg, sep="\t", quote=FALSE, col.names=NA)
close(gzout)
head(all.dvg)
```

We can examine the top hits in more detail.
Changes in variability between conditions are mostly driven by differential expression, as one might expect.

```{r}
matching <- rownames(sce)[rowData(sce)$ensembl_gene_id %in% rownames(all.dvg)[1:4]]
plotExpression(sce, features=matching, x="sample", colour_by="phenotype")
```

## Examining specific gene sets

### Germ layers

We throw ROAST at the gene set used to characterize each germ layer (curated by Ferdinand).

```{r}
by.lineage <- read.table("miscellaneous/commit_lineages.tsv", header=TRUE, stringsAsFactors=FALSE)
endo.set <- by.lineage$Symbol[grep("endoderm", by.lineage$Germ_layer)]
head(endo.set)
ecto.set <- by.lineage$Symbol[grep("ectoderm", by.lineage$Germ_layer)]
head(ecto.set)
meso.set <- by.lineage$Symbol[grep("mesoderm", by.lineage$Germ_layer)]
head(meso.set)
```

Setting up a function to identify the surviving genes.

```{r}
library(org.Hs.eg.db)
inPresentSet <- function(present, desired) {
    ensembls <- mapIds(org.Hs.eg.db, keytype="SYMBOL", keys=desired, column="ENSEMBL")
    which(present %in% ensembls)    
}
```

Checking whether there's evidence for an increase in variability in the primed condition (`Up`) in the gene sets defining each germ layer.

```{r}
endo.keep <- inPresentSet(rownames(bio.tab2), endo.set)
roast(bio.tab2, index=endo.keep, design=design, coef=ncol(design)) 
ecto.keep <- inPresentSet(rownames(bio.tab2), ecto.set)
roast(bio.tab2, index=ecto.keep, design=design, coef=ncol(design)) 
meso.keep <- inPresentSet(rownames(bio.tab2), meso.set)
roast(bio.tab2, index=meso.keep, design=design, coef=ncol(design)) 
```

## Characterizing the function of the DVGs

We have a look at the genes that are more variable in primed cells.

```{r}
entreznames <- as.character(rowData(sce)$entrezgene)
has.entrez <- !is.na(entreznames)
all.tested <- rownames(all.dvg)
in.universe <- entreznames[rowData(sce)$ensembl_gene_id %in% all.tested & has.entrez]

dvg.in.primed <- rownames(all.dvg)[all.dvg$adj.P.Val <= 0.05 & all.dvg$logFC > 0]
in.primed <- entreznames[rowData(sce)$ensembl_gene_id %in% dvg.in.primed & has.entrez]

go <- goana(in.primed, universe=in.universe, species="Hs")
topgo <- topGO(go, n=Inf, ontology = "BP") 
write.table(file=file.path(resdir, "go_dvg_primed.tsv"), topgo, sep="\t", quote=FALSE, col.names = NA) 
head(topgo)

kegg <- kegga(in.primed, universe=in.universe, species="Hs")
topkegg <- topKEGG(kegg, n=Inf)
write.table(file=file.path(resdir, "kegg_dvg_primed.tsv"), topkegg, sep="\t", quote=FALSE, col.names = NA) 
head(topkegg)
```

Repeating the dose for DVGs that go in the other direction.

```{r}
dvg.in.naive <- rownames(all.dvg)[all.dvg$adj.P.Val <= 0.05 & all.dvg$logFC < 0]
in.naive <- entreznames[rowData(sce)$ensembl_gene_id %in% dvg.in.naive & has.entrez]

go <- goana(in.naive, universe=in.universe, species="Hs")
topgo <- topGO(go, n=Inf, ontology = "BP") 
write.table(file=file.path(resdir, "go_dvg_naive.tsv"), topgo, sep="\t", quote=FALSE, col.names = NA) 
head(topgo)

kegg <- kegga(in.naive, universe=in.universe, species="Hs")
topkegg <- topKEGG(kegg, n=Inf)
write.table(file=file.path(resdir, "kegg_dvg_naive.tsv"), topkegg, sep="\t", quote=FALSE, col.names = NA) 
head(topkegg)
```

### Chosen marker sets

Checking for increased variability and correlations within each gene set.

```{r}
chosen_markers <- read.table("miscellaneous/ferd_marker_set.csv", header=TRUE, sep=';', stringsAsFactors = FALSE)
chosen_markers <- chosen_markers[chosen_markers[,1] %in% rownames(sce),]
#chosen_markers[,1] <- mapIds(org.Hs.eg.db, keytype="SYMBOL", keys=chosen_markers[,1], column="ENSEMBL")

endo.set <- chosen_markers$V1[grep("endoderm", chosen_markers$V2)]
endo <- inPresentSet(rownames(var.tab2), endo.set)
roast(var.tab2, index=endo, design=design, coef=ncol(design))
endo.pairs1 <- correlatePairs(sce_primed[,sce_primed$batch ==1], subset.row = endo.set)
endo.pairs2 <- correlatePairs(sce_primed[,sce_primed$batch ==2], subset.row = endo.set)

ecto.set <- chosen_markers$V1[grep("ectoderm", chosen_markers$V2)]
ecto <- inPresentSet(rownames(var.tab2), ecto.set)
roast(var.tab2, index=ecto, design=design, coef=ncol(design)) 
ecto.pairs1 <- correlatePairs(sce_primed[,sce_primed$batch ==1], subset.row = ecto.set)
ecto.pairs2 <- correlatePairs(sce_primed[,sce_primed$batch ==2], subset.row = ecto.set)

meso.set <- chosen_markers$V1[grep("mesoderm", chosen_markers$V2)]
meso <- inPresentSet(rownames(var.tab2), meso.set)
roast(var.tab2, index=meso, design=design, coef=ncol(design)) 
meso.pairs1 <- correlatePairs(sce_primed[,sce_primed$batch ==1], subset.row = meso.set)
meso.pairs2 <- correlatePairs(sce_primed[,sce_primed$batch ==2], subset.row = meso.set)

trop.set <- chosen_markers$V1[grep("trophectoderm", chosen_markers$V2)]
trop <- inPresentSet(rownames(var.tab2), trop.set)
roast(var.tab2, index=trop, design=design, coef=ncol(design)) 
trop.pairs1 <- correlatePairs(sce_primed[,sce_primed$batch ==1], subset.row = trop.set)
trop.pairs2 <- correlatePairs(sce_primed[,sce_primed$batch ==2], subset.row = trop.set)

core.set <- chosen_markers$V1[grep("core_pluripotency", chosen_markers$V2)]
core <- inPresentSet(rownames(var.tab2), core.set)
roast(var.tab2, index=core, design=design, coef=ncol(design)) 
core.pairs1 <- correlatePairs(sce_primed[,sce_primed$batch ==1], subset.row = core.set)
core.pairs2 <- correlatePairs(sce_primed[,sce_primed$batch ==2], subset.row = core.set)

naive.set <- chosen_markers$V1[grep("naive_pluripotency", chosen_markers$V2)]
naive <- inPresentSet(rownames(var.tab2), naive.set)
roast(var.tab2, index=naive, design=design, coef=ncol(design)) 
naive.pairs1 <- correlatePairs(sce_primed[,sce_primed$batch ==1], subset.row = naive.set)
naive.pairs2 <- correlatePairs(sce_primed[,sce_primed$batch ==2], subset.row = naive.set)

form.set <- chosen_markers$V1[grep("formative_pluripotency", chosen_markers$V2)]
form <- inPresentSet(rownames(var.tab2), form.set)
roast(var.tab2, index=form, design=design, coef=ncol(design)) 
form.pairs1 <- correlatePairs(sce_primed[,sce_primed$batch ==1], subset.row = form.set)
form.pairs2 <- correlatePairs(sce_primed[,sce_primed$batch ==2], subset.row = form.set)

primed.set <- chosen_markers$V1[grep("primed_pluripotency", chosen_markers$V2)]
primed <- inPresentSet(rownames(var.tab2), primed.set)
roast(var.tab2, index=primed, design=design, coef=ncol(design)) 
primed.pairs1 <- correlatePairs(sce_primed[,sce_primed$batch ==1], subset.row = primed.set)
primed.pairs2 <- correlatePairs(sce_primed[,sce_primed$batch ==2], subset.row = primed.set)

germ.set <- chosen_markers$V1[grep("germline", chosen_markers$V2)]
germ <- inPresentSet(rownames(var.tab2), germ.set)
roast(var.tab2, index=germ, design=design, coef=ncol(design)) 
germ.pairs1 <- correlatePairs(sce_primed[,sce_primed$batch ==1], subset.row = germ.set)
germ.pairs2 <- correlatePairs(sce_primed[,sce_primed$batch ==2], subset.row = germ.set)

```


### Epigenetic markers

```{r}
epi_modifier <- read.table("miscellaneous/epigen_modifiers.csv", header=TRUE, sep=';', stringsAsFactors = FALSE)
epi_modifier <- epi_modifier[epi_modifier[,1] %in% rownames(sce),]
mod.pairs1 <- correlatePairs(sce_primed[,sce_primed$batch ==1], subset.row = epi_modifier)
mod.pairs2 <- correlatePairs(sce_primed[,sce_primed$batch ==2], subset.row = epi_modifier)
#epi_modifier <- mapIds(org.Hs.eg.db, keytype="SYMBOL", keys=epi_modifier, column="ENSEMBL")

epi_reader <- read.table("miscellaneous/epigen_readers.csv", header=TRUE, sep=';', stringsAsFactors = FALSE)
epi_reader <- epi_reader[epi_reader[,1] %in% rownames(sce),]
read.pairs1 <- correlatePairs(sce_primed[,sce_primed$batch ==1], subset.row = epi_reader)
read.pairs2 <- correlatePairs(sce_primed[,sce_primed$batch ==2], subset.row = epi_reader)
#epi_reader <- mapIds(org.Hs.eg.db, keytype="SYMBOL", keys=epi_reader, column="ENSEMBL")
```


# Wrapping up

We save our object for later use and report the session information.

```{r}
saveRDS(sce_primed, file="sce_primed.rds")
sessionInfo()
```
