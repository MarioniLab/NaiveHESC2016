---
title: "Single-cell RNA-seq of naive/primed embryonic stem cells: primed-only analysis"
author: Tobias Messmer and Aaron Lun
date: 17 December 2016
output: 
  html_document:
    toc: true
    toc_float: true
    depth: 3
    number_sections: true
    theme: united 
    highlight: tango 
    fig_caption: false
---

```{r, echo=FALSE, results="hide"}
dir.create("figure-primed/", showWarning=FALSE)
knitr::opts_chunk$set(error=FALSE, warning=FALSE, message=FALSE, fig.path="figure-primed/")
options(bitmapType="cairo", width=100)
library(BiocParallel)
register(SerialParam())
```

# Selecting only the primed subpopulations

We select only the primed cells and attempt to identify subpopulations within the primed condition.
This is more sensitive than doing so on the entire data set, where the naive/primed differences dominate.

```{r primedin}
library(scran)
sce <- readRDS("sce_all.rds")
sce_primed <- sce[,colData(sce)$phenotype=="primed"] 
dim(sce_primed)
```

We adjust the `batch` factor to get rid of the now-unnecessary "naive" level. 
We also re-normalize to rescale the size factors at unity, so that they are comparable between spike-ins and endogenous genes.

```{r}
sce_primed$batch <- factor(sce_primed$batch)
sce_primed <- normalize(sce_primed)
```

We can examine the expression of the various ESC markers in more detail.

```{r primedExpMarker}
fontsize <- theme(axis.text=element_text(size=12), axis.title=element_text(size=16))
plotExpression(sce_primed, c("KLF4", "KLF17", "DPPA3", "TFCP2L1", "NANOG", "ZFP42", "POU5F1"),
    colour_by="batch") + fontsize
```

We also set up an output directory for the results.

```{r primedout}
resdir <- "results-primed"
dir.create(resdir, showWarning=FALSE)
```

# Detecting primed-only HVGs

We detect HVGs in the primed population, using the variance of the normalized log-expression values.
A trend is fitted to the spike-in variances and represents the technical aspect of variability.
This is done separately for each batch due to the differences in spike-in quantity.
The trend is okay, though some deviation of the spike-ins is attributable to amplification-induced variability.

```{r primed.vartrend, fig.height=6, fig.width=10}
par(mfrow=c(1,2))
collected.var_primed <- list()
for (b in levels(sce_primed$batch)) {
    cur.sce <- sce_primed[,b==sce_primed$batch]
    cur.sce <- normalize(cur.sce)
    var.fit <- trendVar(cur.sce, method="loess", span=0.4)
    var.out <- decomposeVar(cur.sce, var.fit)
    collected.var_primed[[b]] <- var.out 
    plot(var.out$mean, var.out$total, pch=16, cex=0.6, xlab="Mean log-expression",
        ylab="Variance of log-expression")
    points(var.fit$mean, var.fit$var, pch=16, col="red")
    curve(var.fit$trend(x), col="red", add=TRUE, lwd=2)
}
```

We combine statistics across batches (requiring a gene to be HVG in both batches in order to be detected) and save them to file.
We also look at the distribution of the gene-wise variances.
The biological component is computed as the difference in the total variance and the trend (i.e., the technical component).

```{r primed.varplot}
var.out_primed <- do.call(combineVar, collected.var_primed)
write.table(file=file.path(resdir, "var.tsv"), var.out_primed, sep="\t", quote=FALSE, col.names=NA) 
plot(var.out_primed$mean, var.out_primed$total, pch=16, cex=0.6, xlab="Mean log-expression",
     ylab="Variance of log-expression")
is <- which(isSpike(sce_primed))
points(var.out_primed$mean[is], var.out_primed$total[is], col="red", pch=16)
o <- is[order(var.out_primed$mean[is])]
curve(var.fit$trend(x), col='dodgerblue', lwd=2, add=TRUE)
```

Genes with significantly non-zero biological components at a FDR of 5% are defined as HVGs.

```{r var.primed}
hvg.out_primed <- var.out_primed[which(var.out_primed$FDR <= 0.05 & var.out_primed$bio >= 0.5),]
hvg.out_primed <- hvg.out_primed[order(hvg.out_primed$bio, decreasing=TRUE),]
nrow(hvg.out_primed)
write.table(file=file.path(resdir, "hvg.tsv"), hvg.out_primed, sep="\t", quote=FALSE, col.names = NA) 
head(hvg.out_primed)
```

We check that the HVGs are not being driven by outliers or batch effects.

```{r violin.hvg}
plotExpression(sce_primed, rownames(hvg.out_primed)[1:10], alpha=0.05, 
    colour_by="batch", jitter="jitter") + fontsize
```

# Detecting correlated HVGs

We also assess the pairwise correlations between the genes across the primed cells.
Again, the usual suspects dominate the top set of correlations.

```{r, cor.primed}
set.seed(100) 
design_primed <- model.matrix(~ 0 + sce_primed$batch)
var.cor_primed <- correlatePairs(sce_primed, design = design_primed, 
    subset.row=rownames(hvg.out_primed), per.gene=TRUE)
head(var.cor_primed)
```

We focus on the genes that have significantly large correlations.
This happens to be the majority of HVGs that were originally detected.

```{r, sig.primed}
sig.cor_primed <- var.cor_primed$FDR <= 0.05
summary(sig.cor_primed)
chosen_primed <- var.cor_primed$gene[sig.cor_primed]
saveRDS(file=file.path(resdir, "cor_hvg.rds"), chosen_primed)
length(chosen_primed)
```

```{r, echo=FALSE, results="hide"}
gc()
```

# Performing dimensionality reduction

We remove the batch effect prior to performing dimensionality reduction.

```{r}
library(limma)
norm_exprs(sce_primed) <- removeBatchEffect(exprs(sce_primed), batch=sce_primed$batch) 
```

We then create _t_-SNE plots, using only the set of correlated HVGs.

```{r tsne.primed, fig.width=15, fig.height=6}
tsne1_primed <- plotTSNE(sce_primed, exprs_values="norm_exprs", colour_by=rownames(hvg.out_primed)[1],
    perplexity=5, rand_seed=100, feature_set=chosen_primed) + fontsize
tsne2_primed <- plotTSNE(sce_primed, exprs_values="norm_exprs", colour_by="KLF4",
    perplexity=5, rand_seed=100, feature_set=chosen_primed) + fontsize
tsne3_primed <- plotTSNE(sce_primed, exprs_values="norm_exprs", colour_by="batch",
    perplexity=5, rand_seed=100, feature_set=chosen_primed) + fontsize
multiplot(tsne1_primed, tsne2_primed, tsne3_primed, cols=3)
```

And again, for PCA plots.

```{r pca.primed, fig.width=15, fig.height=6}
pca1_primed <- plotPCA(sce_primed, exprs_values="norm_exprs", colour_by=rownames(hvg.out_primed)[1], 
    feature_set = chosen_primed) + fontsize
pca2_primed <- plotPCA(sce_primed, exprs_values="norm_exprs", colour_by="KLF4", 
    feature_set = chosen_primed) + fontsize
pca3_primed <- plotPCA(sce_primed, exprs_values="norm_exprs", colour_by="batch", 
    feature_set = chosen_primed) + fontsize
multiplot(pca1_primed, pca2_primed, pca3_primed, cols=3)
```

Both plots suggest that there is a small subpopulation off the main bulk of cells.

# Clustering on Euclidean distance

We perform hierarchical clustering on the Euclidean distance, using the correlated HVGs identified previously and the batch-corrected expression values.

```{r primedclust}
chosen.exprs_primed <- norm_exprs(sce_primed)[chosen_primed,]
my.dist_primed <- dist(t(chosen.exprs_primed))
my.tree_primed <- hclust(my.dist_primed, method="ward.D2")
```

To identify the "best" number of clusters, we vary the `k` for tree cutting and examine the resulting silhouette plots.
There's not much evidence for clear separation of the clusters at any `k`.
Many clusters have cells have negative widths that should be allocated to other clusters, indicating that the separation of cells here is quite weak.
As such, we do not perform any clustering.

```{r silhouette, fig.width=10, fig.height=10}
library(cluster)
par(mfrow=c(2,2))
for (k in 2:5){
    my.clusters_primed <- unname(cutree(my.tree_primed, k=k))
    col <- rainbow(k)
    sil <- silhouette(my.clusters_primed, dist = my.dist_primed)
    sil.cols <- col[ifelse(sil[,3] > 0, sil[,1], sil[,2])]
    sil.cols <- sil.cols[order(-sil[,1], sil[,3])]
    plot(sil, main = paste(k, "clusters"), border=sil.cols, 
        col=sil.cols, do.col.sort=FALSE)
}
```

# Comparison of subpopulation heterogeneity

## Overall changes between naive and primed conditions

We compare the variability of the naive and primed populations to each other.
We first look at the number of HVGs detected in each population.

```{r}
var.out_naive <- read.table(file.path("results-naive", "var.tsv"))
hvg.out_naive <- read.table(file.path("results-naive", "hvg.tsv"))
nrow(hvg.out_primed)
nrow(hvg.out_naive)
```

The number is slightly lower in the primed population, though that's probably due to loss of power from increases in the technical variance.

```{r}
plot(var.out_primed$mean, var.out_primed$tech, col="dodgerblue", pch=16, cex=0.5,
    xlab="Mean log-expression", ylab="Technical variance")
points(var.out_naive$mean, var.out_naive$tech, col="orange", pch=16, cex=0.5)
```

In any case, we look at the biological components to compare the variability of the HVGs in each condition.
We do this for the absolute values of components and as a ratio against the technical variance.
(This is because the size of the technical variance can affect the value of the biological component, e.g., scaling of the estimate's sampling distribution.)

```{r compcomp, fig.height=7, fig.width=10}
par(mfrow=c(1,2))
boxplot(list(Primed=hvg.out_primed$bio, Naive=hvg.out_naive$bio), 
    ylab="Biological component", ylim=c(0, 5))
boxplot(list(Primed=hvg.out_primed$bio/hvg.out_primed$tech, 
             Naive=hvg.out_naive$bio/hvg.out_naive$tech), 
    ylab="Biological:technical ratio", ylim=c(0, 5))
```

We also plot the difference against the change in the mean expression to see whether DE is driving the change in variance.
Such genes tend to be difficult to interpret as the biological effect of the change in variability cannot be disentangled from that of differential expression.

```{r varcomp, fig.width=15, fig.height=6}
dbio <- var.out_primed$bio - var.out_naive$bio

# Expression values are not directly comparable between separately-normalized objects.
# Pulling out primed-naive log-fold changes from the overall analysis instead.
de.stats <- read.table(file.path("results-overall", "de.tsv"))
lfc <- -de.stats[rownames(var.out_naive),"logFC"]

par(mfrow=c(1,3))
phvg <- match(rownames(hvg.out_primed), rownames(var.out_primed))
nhvg <- match(rownames(hvg.out_naive), rownames(var.out_naive))
both.hvg <- intersect(phvg, nhvg)
smoothScatter(lfc[both.hvg], dbio[both.hvg], xlab=expression(Log[2]~"fold change"), 
    ylab=expression(Delta*"biological component"), main="Both HVGs")
phvg.only <- setdiff(phvg, nhvg)
smoothScatter(lfc[phvg.only], dbio[phvg.only], xlab=expression(Log[2]~"fold change"), 
    ylab=expression(Delta*"biological component"), main="Primed-only HVGs")
nhvg.only <- setdiff(nhvg, phvg)
smoothScatter(lfc[nhvg.only], dbio[nhvg.only], xlab=expression(Log[2]~"fold change"), 
    ylab=expression(Delta*"biological component"), main="Naive-only HVGs")
```

```{r, echo=FALSE, results="hide"}
gc()
```

## Examining the genes that change in heterogeneity

We perform a gene set analysis on the genes that are detected as HVGs in both conditions.

```{r}
shared.genes <- rownames(var.out_primed)[both.hvg]
is.shared <- rownames(sce_primed) %in% shared.genes
entreznames <- as.vector(rowData(sce_primed)$entrezgene)
has.entrez <- !is.na(entreznames)
go <- goana(entreznames[has.entrez & is.shared], universe=entreznames[has.entrez], species="Hs")
topgo <- topGO(go, n=Inf, ontology = "BP") 
topgo$FDR <- p.adjust(topgo$P.DE, method="BH")
write.table(file=file.path(resdir, "go_shared_hvg.tsv"), topgo, sep="\t", quote=FALSE, col.names = NA) 
head(topgo)
kegg <- kegga(entreznames[has.entrez & is.shared], universe=entreznames[has.entrez], species="Hs")
topkegg <- topKEGG(kegg, n=Inf)
topkegg$FDR <- p.adjust(topkegg$P.DE, method="BH")
write.table(file=file.path(resdir, "kegg_shared_hvg.tsv"), topkegg, sep="\t", quote=FALSE, col.names = NA) 
head(topkegg)
```

We also see what terms are enriched between the two sets.
First, we set up the GO terms.

```{r gosetup}
library(org.Hs.eg.db)
EG.GO <- toTable(org.Hs.egGO2ALLEGS)
EG.GO <- EG.GO[EG.GO$Ontology=="BP",]
all.sets <- split(EG.GO$gene_id, EG.GO$go_id)
```

We apply Fisher's exact test to see whether any terms are enriched in the primed HVGs compared to the naive HVGs.

<!--
This probably isn't the right test.
There are the obvious complaints, of course - genes aren't independent of each other, and the marginals are not fixed.
However, there's also the assumption that the same gene is independent between conditions, in terms of whether it is detected as a HVG.
This is unlikely to be true, as the true variance will be positively correlated across conditions to some extent.
Dependencies will result in conservativeness as the proportions between conditions will be more similar than expected.
I can't think of a better test, though, that attacks the same hypothesis, i.e., the __number__ of HVGs.
Other tests would use the relative sizes of the biological components, which will be affected by small changes at non-HVGs.
-->

```{r runfisher}
out.stats <- list()
for (entry in names(all.sets)) {
    curgenes <- all.sets[[entry]]
    mat <- cbind(c(sum(entreznames[phvg] %in% curgenes, na.rm=TRUE), 
                   sum(!entreznames[phvg] %in% curgenes, na.rm=TRUE)),
                 c(sum(entreznames[nhvg] %in% curgenes, na.rm=TRUE),
                   sum(!entreznames[nhvg] %in% curgenes, na.rm=TRUE)))
    fout <- fisher.test(mat)
    out.stats[[entry]] <- c(mat[1,]/mat[2,], mat[1,], fout$p.value)
}
out.stats <- data.frame(do.call(rbind, out.stats))
colnames(out.stats) <- c("Prop.primed", "Prop.naive", "Num.primed", "Num.naive", "P")
out.stats$FDR <- p.adjust(out.stats$P, method="BH")
```

Finally, annotating the GO terms.

```{r gosummary}
library(GO.db)
go.names <- select(GO.db, keys = rownames(out.stats), columns = "TERM")
go.res <- data.frame(Description=go.names$TERM, out.stats)
go.res <- go.res[order(go.res$P),]
write.table(file=file.path(resdir, "go_diff_hvg.tsv"), go.res, 
    col.names=NA, sep="\t", quote=FALSE)
head(go.res)
```

We repeat the dose with KEGG pathways.
First, setting up the gene sets.

```{r}
EG.KEGG <- toTable(org.Hs.egPATH2EG)
all.sets <- split(EG.KEGG$gene_id, EG.KEGG$path_id)
```

Running through the FET again.

```{r, ref.label="runfisher"}
```

Adding annotation.

```{r}
kegg.names <- getKEGGPathwayNames()
kegg.names <- kegg.names[match(paste0("path:map", names(all.sets)), kegg.names$PathwayID),]
kegg.res <- data.frame(Description=kegg.names$Description, out.stats)
kegg.res <- kegg.res[order(kegg.res$P),]
write.table(file=file.path(resdir, "kegg_diff_hvg.tsv"), kegg.res, 
    col.names=NA, sep="\t", quote=FALSE)
head(kegg.res)
```

## Effect of the cell cycle

We check whether the differences in variability are caused by the cell cycle.

```{r phasecheck}
primed.col <- "#0072B2"
naive.col <- "#e79f00"
sce_naive <- readRDS("sce_naive.rds")
primed.phases <- table(sce_primed$phase)
naive.phases <- table(sce_naive$phase)
barplot(rbind(primed.phases, naive.phases), beside = TRUE, 
    col = c(primed.col, naive.col), ylab="Number of cells")
legend("topright", legend = c("primed", "naive"), 
    fill = c(primed.col, naive.col), bty="n", cex=1.5)
```

## Testing with the CV^2^

We see if our results are recapitulated with the CV^2^ method.
For simplicity, we just apply `technicalCV2` to the results of the second batch.

```{r testcv2, fig.width=10, fig.height=6}
sub.sce <- sce_naive[,sce_naive$batch=="2"]
sub.sce <- normalize(sub.sce)
cv2_naive <- technicalCV2(sub.sce)
sub.sce <- sce_primed[,sce_primed$batch=="2"]
sub.sce <- normalize(sub.sce)
cv2_primed <- technicalCV2(sub.sce, cv2.tol=0.5)
par(mfrow=c(1,2))
is <- isSpike(sce_naive)
plot(cv2_naive$mean, cv2_naive$cv2, log="xy", xlab="Mean", ylab="CV2", 
     main="Naive", ylim=c(0.05, 500))
points(cv2_naive$mean[is], cv2_naive$cv2[is], col="red", pch=16)
points(cv2_naive$mean, cv2_naive$trend, col="red", pch=16, cex=0.5)
plot(cv2_primed$mean, cv2_primed$cv2, log="xy", xlab="Mean", ylab="CV2", 
     main="Primed", ylim=c(0.05, 500))
points(cv2_primed$mean[is], cv2_primed$cv2[is], col="red", pch=16)
points(cv2_primed$mean, cv2_primed$trend, col="red", pch=16, cex=0.5)
```

It seems like there's a systematic increase in the biological CV^2^, in both relative and absolute terms.
This supports the previous results with the log-variance method.

```{r hvgstatscv2, fig.width=10, fig.height=6}
par(mfrow=c(1,2))
abs.primed <- cv2_primed$cv2-cv2_primed$trend
abs.naive <- cv2_naive$cv2-cv2_naive$trend
primed.hvg <- cv2_primed$FDR <= 0.05
sum(primed.hvg, na.rm=TRUE)
naive.hvg <- cv2_naive$FDR <= 0.05
sum(naive.hvg, na.rm=TRUE)
boxplot(list(Primed=abs.primed[primed.hvg], Naive=abs.naive[naive.hvg]), log='y', 
        ylab="Residual CV2 to the trend for HVGs", col=c("dodgerblue", "orange"))
rel.primed <- cv2_primed$cv2/cv2_primed$trend
rel.naive <- cv2_naive$cv2/cv2_naive$trend
boxplot(list(Primed=rel.primed[primed.hvg], Naive=rel.naive[naive.hvg]), log='y', 
        ylab="Ratio of CV2 to the trend for HVGs", col=c("dodgerblue", "orange"))
```

However, I suspect that this is partially driven by the liberalness of the HVG detection.
Previous work suggests that the chi-squared test in `technicalCV2` doesn't seem to properly model the variance of the CV^2^ estimate.
This means that an increase in the technical dispersion will result in more HVGs detected, as the extra estimation variance is not accounted for.

To handle this, I'll repeat the plots above using the top 1000 genes for each statistic.
This avoids any effects of incorrect HVG calling within each condition.
Fortunately, we still see a difference in both the absolute and relative differences between conditions.

```{r topstatscv2, fig.width=10, fig.height=6}
par(mfrow=c(1,2))
top.abs.primed <- order(-abs.primed)[1:1000]
top.abs.naive <- order(-abs.naive)[1:1000]
boxplot(list(Primed=abs.primed[top.abs.primed], Naive=abs.naive[top.abs.naive]),
        log='y', ylab="Top residual CV2 to the trend", col=c("dodgerblue", "orange"))
top.rel.primed <- order(-rel.primed)[1:1000]
top.rel.naive <- order(-rel.naive)[1:1000]
boxplot(list(Primed=rel.primed[top.rel.primed], Naive=rel.naive[top.rel.naive]),
        log='y', ylab="Top ratio of CV2 to the trend", col=c("dodgerblue", "orange"))
```

# Wrapping up

We save our object for later use and report the session information.

```{r}
saveRDS(sce_primed, file="sce_primed.rds")
sessionInfo()
```
