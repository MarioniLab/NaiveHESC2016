---
title: "Single-cell RNA-seq of naive/primed embryonic stem cells: differential variability" 
author: Tobias Messmer and Aaron Lun
date: 13 November 2017
output: 
  html_document:
    toc: true
    toc_float: true
    depth: 3
    number_sections: true
    theme: united 
    highlight: tango 
    fig_caption: false
---

```{r, echo=FALSE, results="hide"}
dir.create("figure-dif/", showWarning=FALSE)
knitr::opts_chunk$set(error=FALSE, warning=FALSE, message=FALSE, fig.path="figure-diff/")
options(bitmapType="cairo", width=100)
library(BiocParallel)
register(SerialParam())
```

# Data preparation

The idea here is to test for whether there are any changes in gene expression of germlayer specific markers within the naive and the primed population, respectively.
This will allow us to determine whether the primed cells prepare for differentiation into the three germ layers.
First, we load the counts of our cells and the germ layer markers.
We identify the transition cells in the naive population to prune them out.
This ensures that we're identifying effects of homogeneous populations.

```{r}
library(scran)
sce <- readRDS("sce_all.rds")
true.groups <- read.table(file.path("results-naive", "groups.tsv"), header=TRUE, stringsAsFactors=FALSE)
sce <- sce[,true.groups$Type[match(colnames(sce), true.groups$Cell)]!="transition"]
sce_naive <- sce[,sce$phenotype == "naive"]
sce_primed <- sce[,sce$phenotype == "primed"]
```

We also set up an output directory.

```{r}
resdir <- "results-diff"
dir.create(resdir, showWarning=FALSE)
```

```{r}
by.lineage <- read.table(file.path("data/marker", "commit_lineages.tsv"), header=TRUE, stringsAsFactors=FALSE)
endo.set <- by.lineage$Symbol[grep("endoderm", by.lineage$Germ_layer)]
head(endo.set)
ecto.set <- by.lineage$Symbol[grep("ectoderm", by.lineage$Germ_layer)]
head(ecto.set)
meso.set <- by.lineage$Symbol[grep("mesoderm", by.lineage$Germ_layer)]
head(meso.set)
lin.markers <- by.lineage$Symbol
```

Setting up a function to identify the surviving genes.

```{r}
library(org.Hs.eg.db)
inPresentSet <- function(present, desired) {
    ensembls <- mapIds(org.Hs.eg.db, keytype="SYMBOL", keys=desired, column="ENSEMBL")
    which(present %in% ensembls)    
}
lin.markers <- inPresentSet(rowData(sce)$ensembl_gene_id, lin.markers)
lin.markers <- rownames(sce)[lin.markers]


#Export the table of the used markers
whole.list <- by.lineage[which(by.lineage$Symbol %in% lin.markers),]
whole.list <- whole.list[(!duplicated(whole.list$Symbol)),]
write.table(file=file.path(resdir, "linmarkers.tsv"), whole.list, sep="\t", quote=FALSE, row.names= F) 
```

Because we removed the transition cells from the naive subpopulation, we have to calculate the PCs freshly.
It is important not to forget to remove the batch effect to ensure that they don't distord the clustering. 


```{r}
library(limma)
library(scater)

par(mfrow=c(1,2))
collected.var_naive <- list()
collected.npcs_naive <- list()
for (b in levels(sce_naive$batch)) {
    cur.sce <- sce_naive[,b==sce_naive$batch]
    cur.sce <- normalize(cur.sce)

    var.fit <- trendVar(cur.sce, method="loess", span=0.4)
    var.out <- decomposeVar(cur.sce, var.fit)
    collected.var_naive[[b]] <- var.out 
    collected.npcs_naive[[b]] <- denoisePCA(cur.sce, var.fit$trend, value="n")
}

var.out_naive <- do.call(combineVar, collected.var_naive)

norm_exprs(sce_naive) <- removeBatchEffect(exprs(sce_naive), batch=sce_naive$batch) 
unlist(collected.npcs_naive)

chosen.npcs_naive <- collected.npcs_naive[[2]]

keep <- var.out_naive$bio > 0
pc.out <- prcomp(t(assay(sce_naive, "norm_exprs")[keep,,drop=FALSE]), rank=chosen.npcs_naive)
reducedDim(sce_naive, "PCA") <- pc.out$x
```

Now we repeat the same for the primed population.

```{r primed.vartrend, fig.height=6, fig.width=10}
par(mfrow=c(1,2))
collected.var_primed <- list()
collected.npcs_primed <-list()
for (b in levels(sce_primed$batch)) {
    cur.sce <- sce_primed[,b==sce_primed$batch]
    cur.sce <- normalize(cur.sce)
    
    var.fit <- trendVar(cur.sce, method="loess", span=0.4)
    var.out <- decomposeVar(cur.sce, var.fit)
    collected.var_primed[[b]] <- var.out 
    collected.npcs_primed[[b]] <- denoisePCA(cur.sce, var.fit$trend, value="n")
}

var.out_primed <- do.call(combineVar, collected.var_primed)

norm_exprs(sce_primed) <- removeBatchEffect(exprs(sce_primed), batch=sce_primed$batch) 
unlist(collected.npcs_primed)

chosen.npcs_primed <- collected.npcs_primed[[2]]

keep <- var.out_primed$bio > 0
pc.out <- prcomp(t(assay(sce_primed, "norm_exprs")[keep,,drop=FALSE]), rank=chosen.npcs_primed)
reducedDim(sce_primed, "PCA") <- pc.out$x
```

We can now have a first glimpse on the the naive and primed populations to check whether they form any clusters and color the PCA/tSNE according to their expression of cell-cycle related genes. If cell-cycle related genes colour different parts of the PCA/tSNE, this is an indication that cell-cycle is the great driver for heterogeneity in the populations.

```{r}
library(ggplot2)
fontsize <- theme(axis.text=element_text(size=12), axis.title=element_text(size=16), title = element_text(size=12))
sce_naive <- runTSNE(sce_naive, use_dimred="PCA", perplexity=10, rand_seed=100)
sce_primed <- runTSNE(sce_primed, use_dimred="PCA", perplexity=10, rand_seed=100)


pca_naive <- plotPCA(sce_naive, exprs_values="norm_exprs", colour_by = "CDK1") + fontsize
tsne_naive <- plotTSNE(sce_naive, exprs_values="norm_exprs", colour_by= "CDK1",
    perplexity=5, rand_seed=100) + fontsize

pca_primed <- plotPCA(sce_primed, exprs_values="norm_exprs", colour_by = "CDK1") + fontsize
tsne_primed <- plotTSNE(sce_primed, exprs_values="norm_exprs", colour_by= "CDK1",
    perplexity=5, rand_seed=100) + fontsize

multiplot(pca_naive, tsne_naive, pca_primed, tsne_primed, cols=2)

saveRDS(tsne_naive, file = 'naive_plot.Rds')
saveRDS(tsne_primed, file = 'primed_plot.Rds')
```

# Naive population clustering

We now want to further assess whether clusters form in the naive population if we only use genes that are specific for the three germlayers. Again, we use PCA and tSNE to visualize potential clustering.

```{r}
pca_naive <- plotPCA(sce_naive, exprs_values="norm_exprs", colour_by = 'CDK1', feature_set = lin.markers) + fontsize
tsne_naive <- plotTSNE(sce_naive, exprs_values="norm_exprs", colour_by= "CDK1", feature_set =  lin.markers, perplexity=5, rand_seed=100) + fontsize

multiplot(pca_naive, tsne_naive)

```

There are no distinct clusters visible and the first principal component is separating the cells with <5% variance, thus we assume that cells are still in a uncommited stage.
We can further colour the plots for specific markers of mesoderm, endoderm and ectoderm to see whether the clustering is in fact independent of the lineage.

```{r}
#mesoderm
pca_naive <- plotPCA(sce_naive, exprs_values="norm_exprs", colour_by = 'SNAI1', feature_set = lin.markers) + fontsize
tsne_naive <- plotTSNE(sce_naive, exprs_values="norm_exprs", colour_by= "SNAI1", feature_set =  lin.markers, perplexity=5, rand_seed=100) + fontsize
multiplot(pca_naive, tsne_naive)
saveRDS(tsne_naive, file = 'naive_tsne1.Rds')

#ectoderm
pca_naive <- plotPCA(sce_naive, exprs_values="norm_exprs", colour_by = 'NES', feature_set = lin.markers) + fontsize
tsne_naive <- plotTSNE(sce_naive, exprs_values="norm_exprs", colour_by= "NES", feature_set =  lin.markers, perplexity=50, rand_seed=100) + fontsize
multiplot(pca_naive, tsne_naive)
saveRDS(tsne_naive, file = 'naive_tsne2.Rds')

#endoderm
pca_naive <- plotPCA(sce_naive, exprs_values="norm_exprs", colour_by = 'GATA4', feature_set = lin.markers) + fontsize
tsne_naive <- plotTSNE(sce_naive, exprs_values="norm_exprs", colour_by= "GATA4", feature_set =  lin.markers, perplexity=5, rand_seed=100) + fontsize
multiplot(pca_naive, tsne_naive)
saveRDS(tsne_naive, file = 'naive_tsne3.Rds')
```


# Primed subpopulation

We now repeat the same analysis for the primed population. Again, it is necessary to remove the batch effects, which becomes obvious in the direct comparison to before removal.

```{r}
pca_primed <- plotPCA(sce_primed, exprs_values="norm_exprs", colour_by = 'CDK1', feature_set = lin.markers) + fontsize
tsne_primed <- plotTSNE(sce_primed, exprs_values="norm_exprs", colour_by= "CDK1", feature_set =  lin.markers, perplexity=5, rand_seed=100) + fontsize

multiplot(pca_primed, tsne_primed)
```

We can also colour the plots again for cell-cycle expression and for key lineage markers.

```{r}
pca_primed <- plotPCA(sce_primed, exprs_values="norm_exprs", colour_by = 'CDK1', feature_set = lin.markers) + fontsize
tsne_primed <- plotTSNE(sce_primed, exprs_values="norm_exprs", colour_by= "CDK1", feature_set =  lin.markers, perplexity=5, rand_seed=100) + fontsize
multiplot(pca_primed, tsne_primed)

#mesoderm
pca_primed <- plotPCA(sce_primed, exprs_values="norm_exprs", colour_by = 'SNAI1', feature_set = lin.markers) + fontsize
tsne_primed <- plotTSNE(sce_primed, exprs_values="norm_exprs", colour_by= "SNAI1", feature_set =  lin.markers, perplexity=5, rand_seed=100) + fontsize
multiplot(pca_primed, tsne_primed)
saveRDS(tsne_primed, file = 'primed_tsne1.Rds')

#ectoderm
pca_primed <- plotPCA(sce_primed, exprs_values="norm_exprs", colour_by = 'NES', feature_set = lin.markers) + fontsize
tsne_primed <- plotTSNE(sce_primed, exprs_values="norm_exprs", colour_by= "NES", feature_set =  lin.markers, perplexity=5, rand_seed=100) + fontsize
multiplot(pca_primed, tsne_primed)
saveRDS(tsne_primed, file = 'primed_tsne2.Rds')

#endoderm
pca_primed <- plotPCA(sce_primed, exprs_values="norm_exprs", colour_by = 'GATA4', feature_set = lin.markers) + fontsize
tsne_primed <- plotTSNE(sce_primed, exprs_values="norm_exprs", colour_by= "GATA4", feature_set =  lin.markers, perplexity=5, rand_seed=100) + fontsize
multiplot(pca_primed, tsne_primed)
saveRDS(tsne_primed, file = 'primed_tsne3.Rds')
```

# Epigenetic regulation

Next, we want to check for correlations between Ferdinand's hand-curated markers and various epigenetic modifiers/readers of interest.
First we load in the new data.

```{r}
markers <- read.csv("data/marker/ferd_marker_set.csv", stringsAsFactors = FALSE, header = FALSE)
head(markers)
chosen_markers <- inPresentSet(rowData(sce_naive)$ensembl_gene_id, markers[,1])
markers <-  markers[markers$V1 %in% rownames(sce)[chosen_markers],]
colnames(markers) <- c('Symbol','Function')

epi_modifier <- read.csv("data/marker/epigen_modifiers.csv", stringsAsFactors = FALSE, header = FALSE)
head(epi_modifier)
epi_modifier <- inPresentSet(rowData(sce_naive)$ensembl_gene_id, epi_modifier[,1])
length(epi_modifier)

epi_reader <- read.csv("data/marker/epigen_readers.csv", stringsAsFactors = FALSE, header = FALSE)
head(epi_reader)
epi_reader <- inPresentSet(rowData(sce_naive)$ensembl_gene_id, epi_reader[,1])
length(epi_reader)

#Export the complete list
all_reader <- data.frame(Symbol = rownames(sce[epi_reader,]), Function = 'epi_reader')
all_modifier <- data.frame(Symbol = rownames(sce[epi_modifier,]), Function = 'epi_modifier')
whole.list <- rbind(markers, all_reader, all_modifier)
whole.list <- whole.list[(!duplicated(whole.list$Symbol)),]
write.table(file=file.path(resdir, "epimarker.tsv"), whole.list, sep="\t", quote=FALSE, row.names= F) 
```

We can now check again whether the populations cluster if we use only markers for core_pluripotency, naive_pluripotency, primed_pluripotency, formative_pluripotency, mesoderm, ectoderm, trophectoderm or endoderm.

We do this first for the naive poputlation, then for the primed population.

```{r naive.pca.single.corr, fig.width=20, fig.height=20}
all.pca <- list(unique(markers[,2]))
all.tsne <- list(unique(markers[,2]))
for (marker.type in unique(markers[,2])){
  marker.set <- rownames(sce_naive[rownames(sce_naive) %in% markers[markers[,2]==marker.type,1],])
  
  all.pca[[marker.type]] <- plotPCA(sce_naive, exprs_values="norm_exprs", colour_by = markers[markers[,2]==marker.type,1][1], feature_set = marker.set) + fontsize
  
  all.tsne[[marker.type]] <- plotTSNE(sce_naive, exprs_values="norm_exprs", colour_by='batch', feature_set = marker.set, perplexity=5, rand_seed=100, check_duplicates = FALSE) + fontsize
}
  
#do.call(multiplot, c(all.pca, list(cols=2)))
#do.call(multiplot, c(all.tsne, list(cols=2)))
```

We now do the same thing for the primed population. 

```{r primed.pca.single.corr, fig.width=20, fig.height=20}
all.pca <- list(unique(markers[,2]))
all.tsne <- list(unique(markers[,2]))
for (marker.type in unique(markers[,2])){
  marker.set <- rownames(sce_primed[rownames(sce_primed) %in% markers[markers[,2]==marker.type,1],])
  
  all.pca[[marker.type]] <- plotPCA(sce_primed, exprs_values="norm_exprs", colour_by = markers[markers[,2]==marker.type,1][1], feature_set = marker.set) + fontsize
  
  all.tsne[[marker.type]] <- plotTSNE(sce_primed, exprs_values="norm_exprs", colour_by= 'batch', feature_set = marker.set, perplexity=5, rand_seed=100, check_duplicates = FALSE) + fontsize
}
  
#do.call(multiplot, c(all.pca, list(cols=2)))
#do.call(multiplot, c(all.tsne, list(cols=2)))
```


# Correlations between specific chosen markers and epigenetic modifiers

We now check for correlations between the markers and epigenetic modifiers.
We first block on the batch of origin and we compute a null distribution to avoid redundant work.
We then separate the markers into the specific type and assess the correlations of epigenetic modifiers to these markers, respectively.
The correlation of for each subset of markers will be exported as tables and stored in a list.
Finally, we print the statistics of the correlations.

We begin with the naive population.

```{r}
ii <- 1
naive_epi_stat <- data.frame(marker=unique(markers[,2]), total.markers = NA, total.corrs = NA, sig.corrs = NA)
naive_epi <- list(unique(markers[,2]))

for (marker.type in unique(markers[,2])){
  current.markers <- markers[markers[,2] == marker.type,]
  chosen_markers <- inPresentSet(rowData(sce_naive)$ensembl_gene_id, current.markers[,1])

  set.seed(10000)
  design <- model.matrix(~sce_naive$batch)
  null.dist <- correlateNull(iters=1e6, design=design)
  vs.mod <- correlatePairs(sce_naive, design=design,    null.dist=null.dist, 
    pairings=list(chosen_markers, c(epi_modifier, epi_reader)))
  sig.count <- sum(vs.mod$FDR <= 0.05)

  gzout <- gzfile(file.path(resdir, paste0("naive_corr_", marker.type, "_vs_epi.tsv.gz")), open="wb")
  write.table(file=gzout, vs.mod, sep="\t", quote=FALSE, col.names=NA)
  close(gzout)
  
  naive_epi_stat[ii,c(2,3,4)] <- c(length(chosen_markers), dim(vs.mod)[1], sig.count)
  naive_epi[[marker.type]] <- vs.mod
  
  ii <- ii+1
}
print(naive_epi_stat)
```

We then merge the correlations for all the markers into one dataframe with the epigenetic markers as rows and the chosen markers as columns.
The cells contain the correlations between each respective gene pair.

```{r}
all.heats <- data.frame()
naive_mat <- data.frame()
primed_mat <- data.frame()
for (marker.type in unique(markers[,2])){
  naive_mat <- rbind(naive_mat, naive_epi[[marker.type]])
  primed_mat <- rbind(primed_mat, primed_epi[[marker.type]])
}

# Combine to one membrane to identify the strongest correlations
combined_mat <- rbind(naive_mat, primed_mat)
combined_mat <- combined_mat[order(combined_mat$p.value),]
combined_mat <- combined_mat[1:200,]

#Identify markers
current.markers <- rownames(sce[rownames(sce) %in% markers$Symbol,])
lineage.names <- unique(c(combined_mat$gene1[combined_mat$gene1 %in% current.markers], 
                          combined_mat$gene2[combined_mat$gene2 %in% current.markers]))
epi.names <- unique(c(combined_mat$gene1[combined_mat$gene1 %in% rownames(sce[c(epi_modifier, epi_reader),])], 
                           combined_mat$gene2[combined_mat$gene2 %in% rownames(sce[c(epi_modifier, epi_reader),])]))

#Create an empty matrix with the size of all possible correlations between Epi-markers and lineage markers
current_mat1 <- current_mat2 <- pvals1 <- pvals2 <- pvals <- matrix(nrow=length(lineage.names), ncol = length(epi.names))
rownames(current_mat1) <- lineage.names
colnames(current_mat1) <- epi.names
rownames(current_mat2) <- lineage.names
colnames(current_mat2) <- epi.names
rownames(pvals1) <- lineage.names
colnames(pvals1) <- epi.names
rownames(pvals2) <- lineage.names
colnames(pvals2) <- epi.names

for (lin in lineage.names){ #Sorts for gene combinations is in the list
  for (epi in epi.names){
      if (any(naive_mat$gene1 == lin & naive_mat$gene2 == epi)){
        current_mat1[lin, epi] <- naive_mat$rho[which(naive_mat$gene1 == lin & naive_mat$gene2 == epi)[1]]
        pvals1[lin, epi] <- naive_mat$FDR[which(naive_mat$gene1 == lin & naive_mat$gene2 == epi)[1]] < 0.05
      }
      else if (any(naive_mat$gene2 == lin & naive_mat$gene1 == epi)){
        current_mat1[lin, epi] <- naive_mat$rho[which(naive_mat$gene2 == lin & naive_mat$gene1 == epi)[1]]
        pvals1[lin, epi] <- naive_mat$FDR[which(naive_mat$gene2 == lin & naive_mat$gene1 == epi)[1]] < 0.05
      }
  else {current_mat1[lin, epi] <- 0; pvals1[lin, epi] <- FALSE}  # assuming that there is 0 correlation if the gene combination doesn't show up
  }
}
 
 
for (lin in lineage.names){ #Sorts for gene combinations is in the list
  for (epi in epi.names){
      if (any(primed_mat$gene1 == lin & primed_mat$gene2 == epi)){
        current_mat2[lin, epi] <- primed_mat$rho[which(primed_mat$gene1 == lin & primed_mat$gene2 == epi)[1]]
        pvals2[lin, epi] <- primed_mat$FDR[which(primed_mat$gene1 == lin & primed_mat$gene2 == epi)[1]] < 0.05

      }
      else if (any(primed_mat$gene2 == lin & primed_mat$gene1 == epi)){
        current_mat2[lin, epi] <- primed_mat$rho[which(primed_mat$gene2 == lin & primed_mat$gene1 == epi)[1]]
        pvals2[lin, epi] <- primed_mat$FDR[which(primed_mat$gene2 == lin & primed_mat$gene1 == epi)[1]] < 0.05
      }
  else {current_mat2[lin, epi] <- 0; pvals2[lin, epi] <- FALSE}  # assuming that there is 0 correlation if the gene combination doesn't show up
  }
}

pvals <- matrix(nrow=length(lineage.names), ncol = length(epi.names), 1)
pvals[pvals1==TRUE & pvals2==TRUE] <- 2 #significant in both
pvals[pvals1==TRUE & pvals2==FALSE] <- 3 #significant in naive
pvals[pvals1==FALSE & pvals2==TRUE] <- 4 #signifcant in primed
  
pheatmap(current_mat1, breaks=seq(-0.5, 0.5, length.out=101), main = 'naive', color = colorRampPalette(c("navy", "white", "orangered"))(101),
         treeheight_row = 0, treeheight_col = 0,cluster_rows = FALSE, cluster_cols = FALSE)
pheatmap(current_mat2, breaks=seq(-0.5, 0.5, length.out=101), main = 'primed', color = colorRampPalette(c("navy", "white", "orangered"))(101),
         treeheight_row = 0, treeheight_col = 0,cluster_rows = FALSE, cluster_cols = FALSE)

plot(current_mat1, current_mat2, xlim = c(-0.5, 0.5) , ylim = c(-0.5, 0.5), xlab = 'Naive correlations', ylab='Primed correlations', col = pvals, pch=16)

saveRDS(current_mat1, 'naive.epi.Rds')
saveRDS(current_mat2, 'primed.epi.Rds')
saveRDS(pvals, 'fdr.corr.Rds')

selection_rows <- tail(order(apply(abs(all.heats),1, mean, na.rm = TRUE)), n=25)
selection_columns <- tail(order(apply(abs(all.heats),2, mean, na.rm = TRUE)), n=25)
naive.epi.heat <- all.heats[selection_rows,selection_columns]
```

Now we can repeat the same two steps with the primed population.

```{r}
ii <- 1
primed_epi_stat <- data.frame(marker=unique(markers[,2]), total.markers = NA, total.corrs = NA, sig.corrs = NA)
primed_epi <- list(unique(markers[,2]))

for (marker.type in unique(markers[,2])){
  current.markers <- markers[markers[,2] == marker.type,]
  chosen_markers <- inPresentSet(rowData(sce_primed)$ensembl_gene_id, current.markers[,1])

  set.seed(10000)
  design <- model.matrix(~sce_primed$batch)
  null.dist <- correlateNull(iters=1e6, design=design)
  vs.mod <- correlatePairs(sce_primed, design=design,    null.dist=null.dist, 
    pairings=list(chosen_markers, c(epi_modifier, epi_reader)))
  sig.count <- sum(vs.mod$FDR <= 0.05)

  gzout <- gzfile(file.path(resdir, paste0("primed_corr_", marker.type, "_vs_epi.tsv.gz")), open="wb")
  write.table(file=gzout, vs.mod, sep="\t", quote=FALSE, col.names=NA)
  close(gzout)
  
  primed_epi_stat[ii,c(2,3,4)] <- c(length(chosen_markers), dim(vs.mod)[1], sig.count)
  primed_epi[[marker.type]] <- vs.mod
  
  ii <- ii+1
}
print(primed_epi_stat)
```

```{r}
all.heats <- data.frame()
for (marker.type in unique(markers[,2])){
  current_list <- primed_epi[[marker.type]] 
  current.markers <- rownames(sce[rownames(sce) %in% markers[markers[,2]==marker.type,1],])
  
  lineage.names <- unique(c(current_list$gene1[current_list$gene1 %in% current.markers], 
                          current_list$gene2[current_list$gene2 %in% current.markers]))
  epi.names <- unique(c(current_list$gene1[current_list$gene1 %in% rownames(sce[c(epi_modifier, epi_reader),])], 
                           current_list$gene2[current_list$gene2 %in% rownames(sce[c(epi_modifier, epi_reader),])]))

  current_mat <- matrix(nrow=length(lineage.names), ncol = length(epi.names))
  rownames(current_mat) <- lineage.names
  colnames(current_mat) <- epi.names

  for (lin in lineage.names){
    for (epi in epi.names){
      if (any(current_list$gene1 == lin & current_list$gene2 == epi)){
        current_mat[lin, epi] <- current_list$rho[which(current_list$gene1 == lin & current_list$gene2 == epi)]
      }
      else if (any(current_list$gene2 == lin & current_list$gene1 == epi)){
        current_mat[lin, epi] <- current_list$rho[which(current_list$gene2 == lin & current_list$gene1 == epi)]
      }
  else {current_mat[lin, epi] <- 0}  # assuming that there is 0 correlation if the gene combination doesn't show up
    }}
  
  if (!any(dim(all.heats)==0)){
  current_mat <- current_mat[,intersect(colnames(all.heats), colnames(current_mat))]
  all.heats <- all.heats[,intersect(colnames(all.heats), colnames(current_mat))]
  }
  
  all.heats <- rbind(all.heats, current_mat)
  
}
selection_rows <- tail(order(apply(abs(all.heats),1, mean, na.rm = TRUE)), n=25)
selection_columns <- tail(order(apply(abs(all.heats),2, mean, na.rm = TRUE)), n=25)
primed.epi.heat <- all.heats[selection_rows,selection_columns]
```

```{r}
library(pheatmap)
pheatmap(current_mat1, breaks=seq(-0.5, 0.5, length.out=101), main = 'naive', color = colorRampPalette(c("navy", "white", "orangered"))(101),
         treeheight_row = 0, treeheight_col = 0,cluster_rows = F, cluster_cols = F)
pheatmap(current_mat2, breaks=seq(-0.5, 0.5, length.out=101), main = 'primed', color = colorRampPalette(c("navy", "white", "orangered"))(101),
         treeheight_row = 0, treeheight_col = 0,cluster_rows = F, cluster_cols = F)

saveRDS(naive.epi.heat, 'naive.epi.Rds')
saveRDS(primed.epi.heat, 'primed.epi.Rds')
```

Printing session information.

```{r}
gc()
sessionInfo()
```
