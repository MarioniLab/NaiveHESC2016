---
title: "Single-cell RNA-seq of naive/primed embryonic stem cells: differential variability" 
author: Tobias Messmer and Aaron Lun
date: 13 November 2017
output: 
  html_document:
    toc: true
    toc_float: true
    depth: 3
    number_sections: true
    theme: united 
    highlight: tango 
    fig_caption: false
---

```{r, echo=FALSE, results="hide"}
dir.create("figure-dif/", showWarning=FALSE)
knitr::opts_chunk$set(error=FALSE, warning=FALSE, message=FALSE, fig.path="figure-diff/")
options(bitmapType="cairo", width=100)
library(BiocParallel)
register(SerialParam())
```

# Data preparation

The idea here is to test for whether there are any changes in gene expression of germlayer specific markers within the naive and the primed population, respectively.
This will allow us to determine whether the primed cells prepare for differentiation into the three germ layers.
First, we load the counts of our cells and the germ layer markers.
We identify the transition cells in the naive population to prune them out.
This ensures that we're identifying effects of homogeneous populations.

```{r}
library(scran)
sce <- readRDS("~/Desktop/analysis/sce_all.rds")
true.groups <- read.table("~/Desktop/analysis/results-naive/groups.tsv", header=TRUE, stringsAsFactors=FALSE)
sce <- sce[,true.groups$Type[match(colnames(sce), true.groups$Cell)]!="transition"]
sce_naive <- sce[,sce$phenotype == "naive"]
sce_primed <- sce[,sce$phenotype == "primed"]
```

We also set up an output directory.

```{r}
resdir <- "results-diff"
dir.create(resdir, showWarning=FALSE)
```

```{r}
by.lineage <- read.table("~/Documents/Studium/Master/2016-10 Cambridge/NaiveHESC2016/miscellaneous/commit_lineages.tsv", header=TRUE, stringsAsFactors=FALSE)
endo.set <- by.lineage$Symbol[grep("endoderm", by.lineage$Germ_layer)]
head(endo.set)
ecto.set <- by.lineage$Symbol[grep("ectoderm", by.lineage$Germ_layer)]
head(ecto.set)
meso.set <- by.lineage$Symbol[grep("mesoderm", by.lineage$Germ_layer)]
head(meso.set)
lin.markers <- by.lineage$Symbol
```

Setting up a function to identify the surviving genes.

```{r}
library(org.Hs.eg.db)
inPresentSet <- function(present, desired) {
    ensembls <- mapIds(org.Hs.eg.db, keytype="SYMBOL", keys=desired, column="ENSEMBL")
    which(present %in% ensembls)    
}
lin.markers <- inPresentSet(rowData(sce)$ensembl_gene_id, lin.markers)
lin.markers <- rownames(sce)[lin.markers]
```

```{r}
#naive.hvg <- read.table(file=file.path('results-naive','hvg.tsv'), header=TRUE, stringsAsFactors=FALSE)
#primed.hvg <- read.table(file=file.path('results-primed','hvg.tsv'), header=TRUE, stringsAsFactors=FALSE)
```

First, we can have a first glimpse on the the naive and primed populations to check whether they form any clusters and color the PCA/tSNE according to their expression of cell-cycle related genes. If cell-cycle related genes colour different parts of the PCA/tSNE, this is an indication that cell-cycle is the great driver for heterogeneity in the populations.

```{r}
library(ggplot2)
fontsize <- theme(axis.text=element_text(size=12), axis.title=element_text(size=16), title = element_text(size=12))

library(scater)
pca_naive <- plotPCA(sce_naive, exprs_values="norm_exprs", colour_by = "CDK1", rerun=TRUE) + fontsize
tsne_naive <- plotTSNE(sce_naive, exprs_values="norm_exprs", colour_by= "CDK1",  rerun=TRUE,
    perplexity=5, rand_seed=100) + fontsize

pca_primed <- plotPCA(sce_primed, exprs_values="norm_exprs", colour_by = "CDK1", rerun=TRUE) + fontsize
tsne_primed <- plotTSNE(sce_primed, exprs_values="norm_exprs", colour_by= "CDK1",  rerun=TRUE,
    perplexity=5, rand_seed=100) + fontsize

multiplot(pca_naive, tsne_naive, pca_primed, tsne_primed, cols=2)
```

# Naive population clustering

We now want to further assess whether clusters form in the naive population if we only use genes that are specific for the three germlayers. Again, we use PCA and tSNE to visualize potential clustering. 
We remove batch effects to ensure that they don't distord the clustering.

```{r}
library(limma)
pca_naive <- plotPCA(sce_naive, exprs_values="norm_exprs", colour_by = 'batch', feature_set = lin.markers, rerun=TRUE) + fontsize
tsne_naive <- plotTSNE(sce_naive, exprs_values="norm_exprs", colour_by= "batch", feature_set =  lin.markers, rerun=TRUE, perplexity=5, rand_seed=100) + fontsize

multiplot(pca_naive, tsne_naive)
norm_exprs(sce_naive) <- removeBatchEffect(exprs(sce_naive), batch=sce_naive$batch)

pca_naive <- plotPCA(sce_naive, exprs_values="norm_exprs", colour_by = 'batch', feature_set = lin.markers, rerun=TRUE) + fontsize
tsne_naive <- plotTSNE(sce_naive, exprs_values="norm_exprs", colour_by= "batch", feature_set =  lin.markers, rerun=TRUE, perplexity=5, rand_seed=100) + fontsize

multiplot(pca_naive, tsne_naive)
```

There are no distinct clusters visible and the first principal component is separating the cells with <5% variance, thus we assume that cells are still in a uncommited stage.
We can further colour the plots for specific markers of mesoderm, endoderm and ectoderm to see whether the clustering is in fact independent of the lineage.

```{r}
#mesoderm
pca_naive <- plotPCA(sce_naive, exprs_values="norm_exprs", colour_by = 'T', feature_set = lin.markers, rerun=TRUE) + fontsize
tsne_naive <- plotTSNE(sce_naive, exprs_values="norm_exprs", colour_by= "SNAI1", feature_set =  lin.markers, rerun=TRUE, perplexity=5, rand_seed=100) + fontsize
multiplot(pca_naive, tsne_naive)
#ectoderm
pca_naive <- plotPCA(sce_naive, exprs_values="norm_exprs", colour_by = 'FGF5', feature_set = lin.markers, rerun=TRUE) + fontsize
tsne_naive <- plotTSNE(sce_naive, exprs_values="norm_exprs", colour_by= "NES", feature_set =  lin.markers, rerun=TRUE, perplexity=5, rand_seed=100) + fontsize
multiplot(pca_naive, tsne_naive)
#endoderm
pca_naive <- plotPCA(sce_naive, exprs_values="norm_exprs", colour_by = 'GATA4', feature_set = lin.markers, rerun=TRUE) + fontsize
tsne_naive <- plotTSNE(sce_naive, exprs_values="norm_exprs", colour_by= "GATA6", feature_set =  lin.markers, rerun=TRUE, perplexity=5, rand_seed=100) + fontsize
multiplot(pca_naive, tsne_naive)
```


# Primed subpopulation

We now repeat the same analysis for the primed population. Again, it is necessary to remove the batch effects, which becomes obvious in the direct comparison to before removal.

```{r}
library(limma)
pca_primed <- plotPCA(sce_primed, exprs_values="norm_exprs", colour_by = 'batch', feature_set = lin.markers, rerun=TRUE) + fontsize
tsne_primed <- plotTSNE(sce_primed, exprs_values="norm_exprs", colour_by= "batch", feature_set =  lin.markers, rerun=TRUE, perplexity=5, rand_seed=100) + fontsize

multiplot(pca_primed, tsne_primed)

norm_exprs(sce_primed) <- removeBatchEffect(exprs(sce_primed), batch=sce_primed$batch)

pca_primed <- plotPCA(sce_primed, exprs_values="norm_exprs", colour_by = 'batch', feature_set = lin.markers, rerun=TRUE) + fontsize
tsne_primed <- plotTSNE(sce_primed, exprs_values="norm_exprs", colour_by= "batch", feature_set =  lin.markers, rerun=TRUE, perplexity=5, rand_seed=100) + fontsize

multiplot(pca_primed, tsne_primed)
```

We can also colour the plots again for cell-cycle expression and for key lineage markers.

```{r}
pca_primed <- plotPCA(sce_primed, exprs_values="norm_exprs", colour_by = 'CDK1', feature_set = lin.markers, rerun=TRUE) + fontsize
tsne_primed <- plotTSNE(sce_primed, exprs_values="norm_exprs", colour_by= "CDK1", feature_set =  lin.markers, rerun=TRUE, perplexity=5, rand_seed=100) + fontsize
multiplot(pca_primed, tsne_primed)
#mesoderm
pca_primed <- plotPCA(sce_primed, exprs_values="norm_exprs", colour_by = 'T', feature_set = lin.markers, rerun=TRUE) + fontsize
tsne_primed <- plotTSNE(sce_primed, exprs_values="norm_exprs", colour_by= "SNAI1", feature_set =  lin.markers, rerun=TRUE, perplexity=5, rand_seed=100) + fontsize
multiplot(pca_primed, tsne_primed)
#ectoderm
pca_primed <- plotPCA(sce_primed, exprs_values="norm_exprs", colour_by = 'FGF5', feature_set = lin.markers, rerun=TRUE) + fontsize
tsne_primed <- plotTSNE(sce_primed, exprs_values="norm_exprs", colour_by= "NES", feature_set =  lin.markers, rerun=TRUE, perplexity=5, rand_seed=100) + fontsize
multiplot(pca_primed, tsne_primed)
#endoderm
pca_primed <- plotPCA(sce_primed, exprs_values="norm_exprs", colour_by = 'GATA4', feature_set = lin.markers, rerun=TRUE) + fontsize
tsne_primed <- plotTSNE(sce_primed, exprs_values="norm_exprs", colour_by= "GATA6", feature_set =  lin.markers, rerun=TRUE, perplexity=5, rand_seed=100) + fontsize
multiplot(pca_primed, tsne_primed)
```

# Epigenetic regulation

Next, we want to check for correlations between Ferdinand's hand-curated markers and various epigenetic modifiers/readers of interest.
First we load in the new data.

```{r}
markers <- read.csv("miscellaneous/ferd_marker_set.csv", stringsAsFactors = FALSE, header = FALSE)
head(markers)
chosen_markers <- inPresentSet(rowData(sce_naive)$ensembl_gene_id, markers[,1])
markers <-  markers[markers$V1 %in% rownames(sce)[chosen_markers],]

epi_modifier <- read.csv("miscellaneous/epigen_modifiers.csv", stringsAsFactors = FALSE, header = FALSE)
head(epi_modifier)
epi_modifier <- inPresentSet(rowData(sce_naive)$ensembl_gene_id, epi_modifier[,1])
length(epi_modifier)

epi_reader <- read.csv("miscellaneous/epigen_readers.csv", stringsAsFactors = FALSE, header = FALSE)
head(epi_reader)
epi_reader <- inPresentSet(rowData(sce_naive)$ensembl_gene_id, epi_reader[,1])
length(epi_reader)
```

We can now check again whether the populations cluster if we use only markers for core_pluripotency, naive_pluripotency, primed_pluripotency, formative_pluripotency, mesoderm, ectoderm, trophectoderm or endoderm.

We do this first for the naive poputlation, then for the primed population.

```{r naive.pca.single.corr, fig.width=20, fig.height=20}
all.pca <- list(unique(markers[,2]))
all.tsne <- list(unique(markers[,2]))
for (marker.type in unique(markers[,2])){
  marker.set <- rownames(sce_naive[rownames(sce_naive) %in% markers[markers[,2]==marker.type,1],])
  
  all.pca[[marker.type]] <- plotPCA(sce_naive, exprs_values="norm_exprs", colour_by = markers[markers[,2]==marker.type,1][1], feature_set = marker.set, rerun=TRUE) + fontsize
  
  all.tsne[[marker.type]] <- plotTSNE(sce_naive, exprs_values="norm_exprs", colour_by='batch', feature_set = marker.set, perplexity=5, rand_seed=100, rerun=TRUE, check_duplicates = FALSE) + fontsize
}
  
#do.call(multiplot, c(all.pca, list(cols=2)))
#do.call(multiplot, c(all.tsne, list(cols=2)))
```

We now do the same thing for the primed population. 

```{r primed.pca.single.corr, fig.width=20, fig.height=20}
all.pca <- list(unique(markers[,2]))
all.tsne <- list(unique(markers[,2]))
for (marker.type in unique(markers[,2])){
  marker.set <- rownames(sce_primed[rownames(sce_primed) %in% markers[markers[,2]==marker.type,1],])
  
  all.pca[[marker.type]] <- plotPCA(sce_primed, exprs_values="norm_exprs", colour_by = markers[markers[,2]==marker.type,1][1], feature_set = marker.set, rerun=TRUE) + fontsize
  
  all.tsne[[marker.type]] <- plotTSNE(sce_primed, exprs_values="norm_exprs", colour_by= 'batch', feature_set = marker.set, perplexity=5, rand_seed=100, rerun=TRUE, check_duplicates = FALSE) + fontsize
}
  
#do.call(multiplot, c(all.pca, list(cols=2)))
#do.call(multiplot, c(all.tsne, list(cols=2)))
```


# Correlations between specific chosen markers and epigenetic modifiers

We now check for correlations between the markers and epigenetic modifiers.
We first block on the batch of origin and we compute a null distribution to avoid redundant work.
We then separate the markers into the specific type and assess the correlations of epigenetic modifiers to these markers, respectively.
The correlation of for each subset of markers will be exported as tables and stored in a list.
Finally, we print the statistics of the correlations.

We begin with the naive population.

```{r}
ii <- 1
naive_mod_stat <- data.frame(marker=unique(markers[,2]), total.markers = NA, total.corrs = NA, sig.corrs = NA)
naive_mod <- list(unique(markers[,2]))

for (marker.type in unique(markers[,2])){
  current.markers <- markers[markers[,2] == marker.type,]
  chosen_markers <- inPresentSet(rowData(sce_naive)$ensembl_gene_id, current.markers[,1])
  set.seed(10000)
  design <- model.matrix(~sce_naive$batch)
  null.dist <- correlateNull(iters=1e6, design=design)
  vs.mod <- correlatePairs(sce_naive, design=design,    null.dist=null.dist, 
    pairings=list(chosen_markers, epi_modifier))
  sig.count <- sum(vs.mod$FDR <= 0.05)

  gzout <- gzfile(file.path(resdir, paste0("naive_corr_", marker.type, "_vs_mod.tsv.gz")), open="wb")
  write.table(file=gzout, vs.mod, sep="\t", quote=FALSE, col.names=NA)
  close(gzout)
  
  naive_mod_stat[ii,c(2,3,4)] <- c(length(chosen_markers), dim(vs.mod)[1], sig.count)
  naive_mod[[marker.type]] <- vs.mod
  
  ii <- ii+1
}
print(naive_mod_stat)
```

Next, we can do the same for epigeentic readers.

```{r}
ii <- 1
naive_read_stat <- data.frame(marker=unique(markers[,2]), total.markers = NA, total.corrs = NA, sig.corrs = NA)
naive_read <- list(unique(markers[,2]))

for (marker.type in unique(markers[,2])){
  current.markers <- markers[markers[,2] == marker.type,]
  chosen_markers <- inPresentSet(rowData(sce_naive)$ensembl_gene_id, current.markers[,1])
  set.seed(10000)
  design <- model.matrix(~sce_naive$batch)
  null.dist <- correlateNull(iters=1e6, design=design)
  vs.read <- correlatePairs(sce_naive, design=design,    null.dist=null.dist, 
    pairings=list(chosen_markers, epi_reader))
  sig.count <- sum(vs.read$FDR <= 0.05)
  vs.read$type <- marker.type


  gzout <- gzfile(file.path(resdir, paste0("naive_corr_", marker.type, "_vs_read.tsv.gz")), open="wb")
  write.table(file=gzout, vs.read, sep="\t", quote=FALSE, col.names=NA)
  close(gzout)
  
  naive_read_stat[ii,c(2,3,4)] <- c(length(chosen_markers), dim(vs.read)[1], sig.count)
  naive_read[[marker.type]] <- vs.read
  
  ii <- ii+1
}
print(naive_read_stat)
```

Now we can repeat the same two steps with the primed population.

```{r}
ii <- 1
primed_mod_stat <- data.frame(marker=unique(markers[,2]), total.markers = NA, total.corrs = NA, sig.corrs = NA)
primed_mod <- list(unique(markers[,2]))

for (marker.type in unique(markers[,2])){
  current.markers <- markers[markers[,2] == marker.type,]
  chosen_markers <- inPresentSet(rowData(sce_primed)$ensembl_gene_id, current.markers[,1])
  set.seed(10000)
  design <- model.matrix(~sce_primed$batch)
  null.dist <- correlateNull(iters=1e6, design=design)
  vs.mod <- correlatePairs(sce_primed, design=design,    null.dist=null.dist, 
    pairings=list(chosen_markers, epi_modifier))
  sig.count <- sum(vs.mod$FDR <= 0.05)

  gzout <- gzfile(file.path(resdir, paste0("primed_corr_", marker.type, "_vs_mod.tsv.gz")), open="wb")
  write.table(file=gzout, vs.mod, sep="\t", quote=FALSE, col.names=NA)
  close(gzout)
  
  primed_mod_stat[ii,c(2,3,4)] <- c(length(chosen_markers), dim(vs.mod)[1], sig.count)
  primed_mod [[marker.type]] <- vs.mod
  
  ii <- ii+1
}
print(primed_mod_stat)
```

Finally, we also repeat it for epigeentic readers in the primed population.

```{r}
ii <- 1
primed_read_stat <- data.frame(marker=unique(markers[,2]), total.markers = NA, total.corrs = NA, sig.corrs = NA)
primed_read <- list(unique(markers[,2]))

for (marker.type in unique(markers[,2])){
  current.markers <- markers[markers[,2] == marker.type,]
  chosen_markers <- inPresentSet(rowData(sce_primed)$ensembl_gene_id, current.markers[,1])
  set.seed(10000)
  design <- model.matrix(~sce_primed$batch)
  null.dist <- correlateNull(iters=1e6, design=design)
  vs.read <- correlatePairs(sce_primed, design=design, null.dist=null.dist, 
    pairings=list(chosen_markers, epi_reader))
  sig.count <- sum(vs.read$FDR <= 0.05)

  gzout <- gzfile(file.path(resdir, paste0("primed_corr_", marker.type, "_vs_read.tsv.gz")), open="wb")
  write.table(file=gzout, vs.read, sep="\t", quote=FALSE, col.names=NA)
  close(gzout)
  
  primed_read_stat[ii,c(2,3,4)] <- c(length(chosen_markers), dim(vs.read)[1], sig.count)
  primed_read[[marker.type]] <- vs.read
  
ii <- ii+1
}
print(primed_read_stat)
```

We can now visualize the statistics in a heatmap.

```{r}
library(pheatmap)
epi_mat <- cbind(naive_mod_stat$sig.corrs, naive_read_stat$sig.corrs, 
               primed_mod_stat$sig.corrs, primed_read_stat$sig.corrs)
rownames(epi_mat) <- gsub('_',' ', naive_mod_stat$marker)
colnames(epi_mat) <- c('modifiers in naive', 'readers in naive', 'modifiers in primed', 'readers in primed')
pheatmap(epi_mat, cluster_row = F, cluster_cols = F, color = colorRampPalette(c("#0072B2","yellow" ,"#e79f00"))(50), display_numbers = epi_mat, fontsize = 20, fontsize_row = 15, fontsize_col = 15, gaps_col = 2)
```

However, it is clearer to make a heatmap of the correlations themselves of the lineage markers.

```{r}
all.heats <- list(unique(markers[,2]))
  
for (marker.type in unique(markers[,2])){
  current_list <-primed_read[[marker.type]] 
  
  lineage.names <- unique(c(current_list$gene1[current_list$gene1 %in% lin.markers], 
                          current_list$gene2[current_list$gene2 %in% lin.markers]))
  epi.read.names <- unique(c(current_list$gene1[current_list$gene1 %in% rownames(sce[epi_reader,])], 
                           current_list$gene2[current_list$gene2 %in% rownames(sce[epi_reader,])]))

  current_mat <- matrix(nrow=length(lineage.names), ncol = length(epi.read.names))
  rownames(current_mat) <- lineage.names
  colnames(current_mat) <- epi.read.names

  for (lin in lineage.names){
    for (epi in epi.read.names){
      if (any(current_list$gene1 == lin & current_list$gene2 == epi)){
        current_mat[lin, epi] <- current_list$rho[which(current_list$gene1 == lin & current_list$gene2 == epi)]
      }
      else if (any(current_list$gene2 == lin & current_list$gene1 == epi)){
        current_mat[lin, epi] <- current_list$rho[which(current_list$gene2 == lin & current_list$gene1 == epi)]
      }
  else {current_mat[lin, epi] <- 0}  # assuming that there is 0 correlation if the gene combination doesn't show up
    }}
  
  all.heats[[marker.type]] <- current_mat
}

```


```{r}
gc()
sessionInfo()
```
